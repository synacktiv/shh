//! Systemd option model

use std::{
    collections::{HashMap, HashSet},
    fmt,
    io::{self, Write},
    iter,
    num::NonZeroUsize,
    os::unix::ffi::OsStrExt as _,
    path::{Path, PathBuf},
    str::FromStr,
};

use crate::{
    cl::HardeningOptions,
    summarize::ProgramAction,
    sysctl,
    systemd::{self, KernelVersion, SystemdVersion, options::specs::OPTION_SPECS},
};

mod specs;

/// Callbacks to dynamically update an option to make it compatible with an action
pub(crate) trait OptionUpdater: fmt::Debug {
    /// Generate a new option effect compatible with the previously incompatible action
    /// If effect contains multiple ones, updater is called once per sub effect
    fn effect(
        &self,
        cur_effect: &OptionValueEffect,
        action: &ProgramAction,
        opts: &HardeningOptions,
    ) -> Option<OptionValueEffect>;

    /// Generate new options from the new effect
    fn options(&self, new_effect: &OptionValueEffect) -> Vec<OptionWithValue<&'static str>>;

    /// Names of the options that might be generated by the updater (used for markdown option list generation)
    fn dynamic_option_names(&self) -> &[&str];
}

/// Systemd option with its possibles values, and their effect
#[derive(Debug)]
pub(crate) struct OptionDescription {
    pub name: &'static str,
    pub possible_values: Vec<OptionValueDescription>,
    pub updater: Option<&'static dyn OptionUpdater>,
}

impl OptionDescription {
    pub(crate) fn write_markdown<W: Write>(&self, w: &mut W) -> io::Result<()> {
        const MARKDOWN_IDENT: &str = "  ";
        writeln!(
            w,
            "- [`{}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{}=)\n",
            self.name, self.name
        )?;
        for opt_val in &self.possible_values {
            if let OptionValue::List(list) = &opt_val.value {
                writeln!(
                    w,
                    "{}- *dynamic {}{}*",
                    MARKDOWN_IDENT,
                    if list.mergeable_paths { "path " } else { "" },
                    match list.mode {
                        ListMode::BlackList => "blacklisting",
                        ListMode::WhiteList => "whitelisting",
                    }
                )?;
                break;
            }
            match &opt_val.value {
                OptionValue::Boolean(v) => {
                    writeln!(
                        w,
                        "{}- `{}`",
                        MARKDOWN_IDENT,
                        if *v { "true" } else { "false" }
                    )?;
                }
                OptionValue::String(v) => writeln!(w, "{MARKDOWN_IDENT}- `{v}`")?,
                OptionValue::List(ListOptionValue { values, .. }) => {
                    for val in values {
                        writeln!(w, "{MARKDOWN_IDENT}- `{val}`")?;
                    }
                }
            }
        }
        if let Some(updater) = &self.updater {
            let mut first = true;
            for new_opt_name in updater
                .dynamic_option_names()
                .iter()
                .filter(|n| **n != self.name)
            {
                if first {
                    writeln!(
                        w,
                        "{MARKDOWN_IDENT}- to support this option, other options may be dynamically enabled:",
                    )?;
                    first = false;
                }
                writeln!(
                    w,
                    "{MARKDOWN_IDENT}{MARKDOWN_IDENT}- [`{new_opt_name}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{new_opt_name}=)"
                )?;
            }
        }
        writeln!(w)
    }
}

impl fmt::Display for OptionDescription {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.name.fmt(f)
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub(crate) enum ListMode {
    WhiteList,
    BlackList,
}

/// Systemd option value
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) enum OptionValue {
    Boolean(bool), // In most case we only model the 'true' value, because false is no-op and the default
    String(String), // enum-like, or free string
    List(ListOptionValue),
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct ListOptionValue {
    pub values: Vec<String>,
    pub value_if_empty: Option<&'static str>,
    pub option_prefix: &'static str,
    pub elem_prefix: &'static str,
    pub repeat_option: bool,
    pub mode: ListMode,
    pub mergeable_paths: bool,
}

impl FromStr for OptionValue {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "true" => Ok(OptionValue::Boolean(true)),
            "false" => Ok(OptionValue::Boolean(false)),
            _ => Ok(OptionValue::String(s.to_owned())),
        }
    }
}

/// A systemd option value and its effects
#[derive(Debug)]
pub(crate) struct OptionValueDescription {
    pub value: OptionValue,
    pub desc: OptionEffect,
}

/// The effects a systemd option has if enabled
#[derive(Debug, Clone)]
pub(crate) enum OptionEffect {
    /// Option has no modeled effect (it will be unconditionally enabled)
    None,
    /// Option has several mutually exclusive possible values
    Simple(OptionValueEffect),
    /// Option has several possible values, that can be combined to stack effects
    Cumulative(Vec<OptionValueEffect>),
}

#[derive(Debug, Clone)]
pub(crate) enum PathDescription {
    Base {
        base: PathBuf,
        exceptions: Vec<PathBuf>,
    },
    Pattern(regex::bytes::Regex),
}

impl PathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self::Base {
            base: base.into(),
            exceptions: vec![],
        }
    }

    pub(crate) fn pattern(pattern: &'static str) -> Self {
        #[expect(clippy::unwrap_used)]
        Self::Pattern(regex::bytes::Regex::new(pattern).unwrap())
    }

    pub(crate) fn matches(&self, path: &Path) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        match self {
            PathDescription::Base { base, exceptions } => {
                path.starts_with(base) && !exceptions.iter().any(|e| path.starts_with(e))
            }
            PathDescription::Pattern(r) => r.is_match(path.as_os_str().as_bytes()),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) struct EmptyPathDescription {
    /// Base path
    pub base: PathBuf,
    /// Whether base path is read only
    pub base_ro: bool,
    /// Read only paths below base
    pub exceptions_ro: Vec<PathBuf>,
    /// Read/write paths below base
    pub exceptions_rw: Vec<PathBuf>,
}

impl EmptyPathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: false,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn base_ro(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: true,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn matches(&self, path: &Path, ro: bool) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        if !path.starts_with(&self.base) {
            return false;
        }
        if ro {
            !self
                .exceptions_ro
                .iter()
                .chain(&self.exceptions_rw)
                .any(|e| path.starts_with(e))
        } else {
            !self.exceptions_rw.iter().any(|e| path.starts_with(e))
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum OptionValueEffect {
    /// Deny an action
    DenyAction(ProgramAction),
    /// Mount path as noexec
    DenyExec(PathDescription),
    /// Deny syscall(s)
    DenySyscalls(DenySyscalls),
    /// Mount path as read only
    DenyWrite(PathDescription),
    /// Mount an empty tmpfs under given directory
    EmptyPath(EmptyPathDescription),
    /// Union of multiple effects
    Multiple(Vec<OptionValueEffect>),
    /// Don't mount path in target namespace
    RemovePath(PathDescription),
}

impl OptionValueEffect {
    /// Merge current effect with another, while avoiding creating nested `Multiple`
    pub(crate) fn merge(&mut self, other: &OptionValueEffect) {
        match self {
            OptionValueEffect::Multiple(effs) => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    effs.extend(oeffs.iter().cloned());
                }
                oeff => {
                    effs.push(oeff.clone());
                }
            },
            eff => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    let mut new_effs = Vec::with_capacity(oeffs.len() + 1);
                    new_effs.push(eff.to_owned());
                    new_effs.extend(oeffs.iter().cloned());
                    *eff = OptionValueEffect::Multiple(new_effs);
                }
                oeff => {
                    *eff = OptionValueEffect::Multiple(vec![eff.to_owned(), oeff.to_owned()]);
                }
            },
        }
    }

    /// Get an iterator over effects
    pub(crate) fn iter<'a>(&'a self) -> Box<dyn Iterator<Item = &'a Self> + 'a> {
        match self {
            OptionValueEffect::Multiple(effs) => Box::new(effs.iter()),
            _ => Box::new(iter::once(self)),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum DenySyscalls {
    /// See <https://github.com/systemd/systemd/blob/v254/src/shared/seccomp-util.c#L306>
    /// for the content of each class
    Class(&'static str),
    Single(&'static str),
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketFamily {
    Ipv4,
    Ipv6,
    Other(String),
}

impl FromStr for SocketFamily {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "AF_INET" => Ok(Self::Ipv4),
            "AF_INET6" => Ok(Self::Ipv6),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketProtocol {
    Tcp,
    Udp,
    Other(String),
}

impl FromStr for SocketProtocol {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "SOCK_STREAM" => Ok(Self::Tcp),
            "SOCK_DGRAM" => Ok(Self::Udp),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

impl DenySyscalls {
    /// Get denied syscall names
    pub(crate) fn syscalls(&self) -> HashSet<&'static str> {
        match self {
            Self::Class(class) => {
                #[expect(clippy::unwrap_used)]
                let mut content: HashSet<_> = SYSCALL_CLASSES
                    .get(class)
                    .unwrap()
                    .iter()
                    .copied()
                    .collect();
                while content.iter().any(|e| e.starts_with('@')) {
                    content = content
                        .iter()
                        .filter_map(|c| {
                            #[expect(clippy::unwrap_used)]
                            c.strip_prefix('@')
                                .map(|cn| SYSCALL_CLASSES.get(cn).unwrap())
                        })
                        .flatten()
                        .chain(content.iter().filter(|e| !e.starts_with('@')))
                        .copied()
                        .collect();
                }
                content
            }
            Self::Single(sc) => HashSet::from([sc.to_owned()]),
        }
    }
}

/// A systemd option with a value, as would be present in a config file
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct OptionWithValue<T> {
    pub name: T,
    pub value: OptionValue,
}

impl<T: PartialEq> OptionWithValue<T> {
    /// Merge current option with another if we can, return true if we succeeded
    pub(crate) fn merge(&mut self, other: &Self) -> bool {
        if self.name == other.name {
            match (&mut self.value, &other.value) {
                (
                    OptionValue::List(ListOptionValue {
                        values,
                        value_if_empty,
                        option_prefix,
                        elem_prefix,
                        repeat_option,
                        mode,
                        mergeable_paths,
                    }),
                    OptionValue::List(ListOptionValue {
                        values: ovalues,
                        value_if_empty: ovalue_if_empty,
                        option_prefix: ooption_prefix,
                        elem_prefix: oelem_prefix,
                        repeat_option: orepeat_option,
                        mode: omode,
                        mergeable_paths: omergeable_paths,
                    }),
                ) if value_if_empty == ovalue_if_empty
                    && option_prefix == ooption_prefix
                    && elem_prefix == oelem_prefix
                    && repeat_option == orepeat_option
                    && mode == omode
                    && mergeable_paths == omergeable_paths =>
                {
                    values.extend(ovalues.iter().cloned());
                    values.sort_unstable();
                    true
                }
                _ => false,
            }
        } else {
            false
        }
    }
}

impl FromStr for OptionWithValue<String> {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (name, value) = s
            .split_once('=')
            .ok_or_else(|| anyhow::anyhow!("Missing '=' char in {s:?}"))?;

        Ok(Self {
            name: name.to_owned(),
            #[expect(clippy::unwrap_used)] // never fails
            value: value.parse().unwrap(),
        })
    }
}

impl<T: fmt::Display> fmt::Display for OptionWithValue<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            OptionValue::Boolean(value) => {
                write!(f, "{}={}", self.name, if *value { "true" } else { "false" })
            }
            OptionValue::String(value) => write!(f, "{}={}", self.name, value),
            OptionValue::List(ListOptionValue {
                values,
                value_if_empty,
                option_prefix,
                elem_prefix,
                repeat_option,
                ..
            }) => {
                if values.is_empty() {
                    write!(f, "{}=", self.name)?;
                    if let Some(value_if_empty) = value_if_empty {
                        write!(f, "{value_if_empty}")
                    } else {
                        unreachable!()
                    }
                } else if *repeat_option {
                    for (i, value) in values.iter().enumerate() {
                        write!(f, "{}={}{}{}", self.name, option_prefix, elem_prefix, value)?;
                        if i < values.len() - 1 {
                            writeln!(f)?;
                        }
                    }
                    Ok(())
                } else {
                    write!(
                        f,
                        "{}={}{}",
                        self.name,
                        option_prefix,
                        values
                            .iter()
                            .map(|v| format!("{elem_prefix}{v}"))
                            .collect::<Vec<_>>()
                            .join(" ")
                    )
                }
            }
        }
    }
}

// Syscall groups generated at build time
include!(concat!(env!("OUT_DIR"), "/systemd_syscall_groups.rs"));

pub(crate) fn merge_similar_paths(
    paths: &[PathBuf],
    simplify_threshold: Option<NonZeroUsize>,
) -> Vec<PathBuf> {
    match simplify_threshold {
        Some(simplify_threshold) if paths.len() > simplify_threshold.get() => {
            let mut children: HashMap<PathBuf, HashSet<PathBuf>> = HashMap::new();
            for path in paths {
                let ancestors: Vec<_> = path.ancestors().map(Path::to_path_buf).collect();
                let mut parent: Option<PathBuf> = None;
                for dir in ancestors.into_iter().rev() {
                    if let Some(parent) = parent.as_ref() {
                        children
                            .entry(parent.to_owned())
                            .or_default()
                            .insert(dir.clone());
                    }
                    parent = Some(dir);
                }
            }
            let initial_candidates = vec![PathBuf::from("/")];
            let mut candidates = initial_candidates.clone();
            loop {
                let mut advancing = false;
                let mut new_candidates = Vec::with_capacity(candidates.len());
                for candidate in &candidates {
                    match children.get(candidate) {
                        Some(candidate_children) if !paths.contains(candidate) => {
                            new_candidates.extend(candidate_children.iter().cloned());
                            advancing |= !candidate_children.is_empty();
                        }
                        _ => {
                            new_candidates.push(candidate.to_owned());
                        }
                    }
                }
                // Bail out if:
                // not progressing anymore (paths don't have children)
                if !advancing
                // previous candidate count were lower, and new one is above threshold
                || ((new_candidates.len() > simplify_threshold.get())
                    && (candidates.len() < new_candidates.len())
                    && (candidates != initial_candidates))
                // not less path than initial input
                || (new_candidates.len() >= paths.len())
                {
                    break;
                }
                candidates = new_candidates;
            }
            if candidates == initial_candidates {
                paths.to_vec()
            } else {
                candidates.sort_unstable();
                candidates
            }
        }
        _ => {
            let mut paths: Vec<_> = paths
                .iter()
                .filter(|e| !paths.iter().any(|oe| *e != oe && e.starts_with(oe)))
                .cloned()
                .collect();
            paths.sort_unstable();
            paths
        }
    }
}

fn action_path_exception(action_path: PathBuf) -> PathBuf {
    if action_path
        .symlink_metadata()
        .is_ok_and(|m| m.file_type().is_symlink())
    {
        // systemd follows symlinks, so won't bind mount the symlink,
        // add exception for parent instead
        action_path
            .parent()
            .map(Path::to_path_buf)
            .unwrap_or(action_path)
    } else {
        action_path
    }
}

/// Context passed to option builders to determine which options are enabled
struct OptionContext<'a> {
    pub systemd_version: &'a SystemdVersion,
    pub kernel_version: &'a KernelVersion,
    pub sysctl_state: &'a sysctl::State,
    pub instance_kind: &'a systemd::InstanceKind,
    pub container: bool,
    pub hardening_opts: &'a HardeningOptions,
}

impl OptionContext<'_> {
    fn is_system_instance(&self) -> bool {
        matches!(self.instance_kind, systemd::InstanceKind::System)
    }

    fn can_use_namespaces(&self) -> bool {
        self.is_system_instance() || self.sysctl_state.kernel_unprivileged_userns_clone
    }

    fn container_unit(&self) -> bool {
        self.container
    }

    fn systemd_min_version(&self, major: u16, minor: u16) -> bool {
        *self.systemd_version >= SystemdVersion::new(major, minor)
    }

    fn kernel_min_version(&self, major: u16, minor: u16, patch: u16) -> bool {
        *self.kernel_version >= KernelVersion::new(major, minor, patch)
    }
}

pub(crate) fn build_options(
    systemd_version: &SystemdVersion,
    kernel_version: &KernelVersion,
    sysctl_state: &sysctl::State,
    instance_kind: &systemd::InstanceKind,
    container: bool,
    hardening_opts: &HardeningOptions,
) -> Vec<OptionDescription> {
    let ctx = OptionContext {
        systemd_version,
        kernel_version,
        sysctl_state,
        instance_kind,
        container,
        hardening_opts,
    };

    // Build options from the static registry
    let options: Vec<OptionDescription> = OPTION_SPECS
        .iter()
        .filter(|spec| spec.enabled_if(&ctx))
        .map(|spec| spec.build(&ctx))
        .filter(|desc| {
            ctx.hardening_opts
                .systemd_options
                .as_ref()
                .is_none_or(|whitelist| whitelist.iter().any(|wo| desc.name == wo))
        })
        .collect();

    log::debug!("{options:#?}");
    options
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn merge_similar_paths_works() {
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/ab/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ab/ab3"),
                    PathBuf::from("/a/ab/ab4/abc")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/ab")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a1/ab/ab1"),
                    PathBuf::from("/a2/ab/ab2"),
                    PathBuf::from("/a3/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![
                PathBuf::from("/a1/ab/ab1"),
                PathBuf::from("/a2/ab/ab2"),
                PathBuf::from("/a3/ab/ab3")
            ]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ac/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/aa/ab2"),
                    PathBuf::from("/a/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/aa"), PathBuf::from("/a/ab")]
        );
        for threshold in [2, 5] {
            assert_eq!(
                merge_similar_paths(
                    &[
                        PathBuf::from("/a"),
                        PathBuf::from("/a/b"),
                        PathBuf::from("/a/b/c"),
                        PathBuf::from("/d/b/c"),
                    ],
                    Some(NonZeroUsize::new(threshold).unwrap())
                ),
                vec![PathBuf::from("/a"), PathBuf::from("/d/b/c")]
            );
        }
    }
}
