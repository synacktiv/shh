//! Systemd option model

// Last updated for systemd v257

use std::{
    borrow::ToOwned,
    collections::{HashMap, HashSet},
    fmt, fs,
    io::{self, Write},
    iter,
    num::NonZeroUsize,
    os::unix::ffi::OsStrExt as _,
    path::{Path, PathBuf},
    str::FromStr,
};

use itertools::Itertools as _;
use strum::IntoEnumIterator as _;

use crate::{
    cl::{HardeningMode, HardeningOptions},
    summarize::{NetworkActivity, NetworkActivityKind, ProgramAction, SetSpecifier},
    sysctl,
    systemd::{self, KernelVersion, SystemdVersion},
};

/// Callbacks to dynamically update an option to make it compatible with an action
#[derive(Debug)]
pub(crate) struct OptionUpdater {
    /// Generate a new option effect compatible with the previously incompatible action
    /// If effect contains multiple ones, updater is called once per sub effect
    pub effect:
        fn(&OptionValueEffect, &ProgramAction, &HardeningOptions) -> Option<OptionValueEffect>,
    /// Generate new options from the new effect
    pub options: fn(&OptionValueEffect) -> Vec<OptionWithValue<&'static str>>,
    /// Names of the options that might be generated by the updater (used for markdown option list generation)
    pub dynamic_option_names: Vec<&'static str>,
}

/// Systemd option with its possibles values, and their effect
#[derive(Debug)]
pub(crate) struct OptionDescription {
    pub name: &'static str,
    pub possible_values: Vec<OptionValueDescription>,
    pub updater: Option<OptionUpdater>,
}

impl OptionDescription {
    pub(crate) fn write_markdown<W: Write>(&self, w: &mut W) -> io::Result<()> {
        const MARKDOWN_IDENT: &str = "  ";
        writeln!(
            w,
            "- [`{}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{}=)\n",
            self.name, self.name
        )?;
        for opt_val in &self.possible_values {
            if let OptionValue::List(list) = &opt_val.value {
                writeln!(
                    w,
                    "{}- *dynamic {}{}*",
                    MARKDOWN_IDENT,
                    if list.mergeable_paths { "path " } else { "" },
                    match list.mode {
                        ListMode::BlackList => "blacklisting",
                        ListMode::WhiteList => "whitelisting",
                    }
                )?;
                break;
            }
            match &opt_val.value {
                OptionValue::Boolean(v) => {
                    writeln!(
                        w,
                        "{}- `{}`",
                        MARKDOWN_IDENT,
                        if *v { "true" } else { "false" }
                    )?;
                }
                OptionValue::String(v) => writeln!(w, "{MARKDOWN_IDENT}- `{v}`")?,
                OptionValue::List(ListOptionValue { values, .. }) => {
                    for val in values {
                        writeln!(w, "{MARKDOWN_IDENT}- `{val}`")?;
                    }
                }
            }
        }
        if let Some(updater) = &self.updater {
            let mut first = true;
            for new_opt_name in updater
                .dynamic_option_names
                .iter()
                .filter(|n| **n != self.name)
            {
                if first {
                    writeln!(
                        w,
                        "{MARKDOWN_IDENT}- to support this option, other options may be dynamically enabled:",
                    )?;
                    first = false;
                }
                writeln!(
                    w,
                    "{MARKDOWN_IDENT}{MARKDOWN_IDENT}- [`{new_opt_name}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{new_opt_name}=)"
                )?;
            }
        }
        writeln!(w)
    }
}

impl fmt::Display for OptionDescription {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.name.fmt(f)
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub(crate) enum ListMode {
    WhiteList,
    BlackList,
}

/// Systemd option value
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) enum OptionValue {
    Boolean(bool), // In most case we only model the 'true' value, because false is no-op and the default
    String(String), // enum-like, or free string
    List(ListOptionValue),
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct ListOptionValue {
    pub values: Vec<String>,
    pub value_if_empty: Option<&'static str>,
    pub option_prefix: &'static str,
    pub elem_prefix: &'static str,
    pub repeat_option: bool,
    pub mode: ListMode,
    pub mergeable_paths: bool,
}

impl FromStr for OptionValue {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "true" => Ok(OptionValue::Boolean(true)),
            "false" => Ok(OptionValue::Boolean(false)),
            _ => Ok(OptionValue::String(s.to_owned())),
        }
    }
}

/// A systemd option value and its effects
#[derive(Debug)]
pub(crate) struct OptionValueDescription {
    pub value: OptionValue,
    pub desc: OptionEffect,
}

/// The effects a systemd option has if enabled
#[derive(Debug, Clone)]
pub(crate) enum OptionEffect {
    /// Option has no modeled effect (it will be unconditionally enabled)
    None,
    /// Option has several mutually exclusive possible values
    Simple(OptionValueEffect),
    /// Option has several possible values, that can be combined to stack effects
    Cumulative(Vec<OptionValueEffect>),
}

#[derive(Debug, Clone)]
pub(crate) enum PathDescription {
    Base {
        base: PathBuf,
        exceptions: Vec<PathBuf>,
    },
    Pattern(regex::bytes::Regex),
}

impl PathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self::Base {
            base: base.into(),
            exceptions: vec![],
        }
    }

    pub(crate) fn pattern(pattern: &'static str) -> Self {
        #[expect(clippy::unwrap_used)]
        Self::Pattern(regex::bytes::Regex::new(pattern).unwrap())
    }

    pub(crate) fn matches(&self, path: &Path) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        match self {
            PathDescription::Base { base, exceptions } => {
                path.starts_with(base) && !exceptions.iter().any(|e| path.starts_with(e))
            }
            PathDescription::Pattern(r) => r.is_match(path.as_os_str().as_bytes()),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) struct EmptyPathDescription {
    /// Base path
    pub base: PathBuf,
    /// Whether base path is read only
    pub base_ro: bool,
    /// Read only paths below base
    pub exceptions_ro: Vec<PathBuf>,
    /// Read/write paths below base
    pub exceptions_rw: Vec<PathBuf>,
}

impl EmptyPathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: false,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn base_ro(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: true,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn matches(&self, path: &Path, ro: bool) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        if !path.starts_with(&self.base) {
            return false;
        }
        if ro {
            !self
                .exceptions_ro
                .iter()
                .chain(&self.exceptions_rw)
                .any(|e| path.starts_with(e))
        } else {
            !self.exceptions_rw.iter().any(|e| path.starts_with(e))
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum OptionValueEffect {
    /// Deny an action
    DenyAction(ProgramAction),
    /// Mount path as noexec
    DenyExec(PathDescription),
    /// Deny syscall(s)
    DenySyscalls(DenySyscalls),
    /// Mount path as read only
    DenyWrite(PathDescription),
    /// Mount an empty tmpfs under given directory
    EmptyPath(EmptyPathDescription),
    /// Union of multiple effects
    Multiple(Vec<OptionValueEffect>),
    /// Don't mount path in target namespace
    RemovePath(PathDescription),
}

impl OptionValueEffect {
    /// Merge current effect with another, while avoiding creating nested `Multiple`
    pub(crate) fn merge(&mut self, other: &OptionValueEffect) {
        match self {
            OptionValueEffect::Multiple(effs) => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    effs.extend(oeffs.iter().cloned());
                }
                oeff => {
                    effs.push(oeff.clone());
                }
            },
            eff => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    let mut new_effs = Vec::with_capacity(oeffs.len() + 1);
                    new_effs.push(eff.to_owned());
                    new_effs.extend(oeffs.iter().cloned());
                    *eff = OptionValueEffect::Multiple(new_effs);
                }
                oeff => {
                    *eff = OptionValueEffect::Multiple(vec![eff.to_owned(), oeff.to_owned()]);
                }
            },
        }
    }

    /// Get an iterator over effects
    pub(crate) fn iter<'a>(&'a self) -> Box<dyn Iterator<Item = &'a Self> + 'a> {
        match self {
            OptionValueEffect::Multiple(effs) => Box::new(effs.iter()),
            _ => Box::new(iter::once(self)),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum DenySyscalls {
    /// See <https://github.com/systemd/systemd/blob/v254/src/shared/seccomp-util.c#L306>
    /// for the content of each class
    Class(&'static str),
    Single(&'static str),
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketFamily {
    Ipv4,
    Ipv6,
    Other(String),
}

impl FromStr for SocketFamily {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "AF_INET" => Ok(Self::Ipv4),
            "AF_INET6" => Ok(Self::Ipv6),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketProtocol {
    Tcp,
    Udp,
    Other(String),
}

impl FromStr for SocketProtocol {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "SOCK_STREAM" => Ok(Self::Tcp),
            "SOCK_DGRAM" => Ok(Self::Udp),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

impl DenySyscalls {
    /// Get denied syscall names
    pub(crate) fn syscalls(&self) -> HashSet<&'static str> {
        match self {
            Self::Class(class) => {
                #[expect(clippy::unwrap_used)]
                let mut content: HashSet<_> = SYSCALL_CLASSES
                    .get(class)
                    .unwrap()
                    .iter()
                    .copied()
                    .collect();
                while content.iter().any(|e| e.starts_with('@')) {
                    content = content
                        .iter()
                        .filter_map(|c| {
                            #[expect(clippy::unwrap_used)]
                            c.strip_prefix('@')
                                .map(|cn| SYSCALL_CLASSES.get(cn).unwrap())
                        })
                        .flatten()
                        .chain(content.iter().filter(|e| !e.starts_with('@')))
                        .copied()
                        .collect();
                }
                content
            }
            Self::Single(sc) => HashSet::from([sc.to_owned()]),
        }
    }
}

/// A systemd option with a value, as would be present in a config file
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct OptionWithValue<T> {
    pub name: T,
    pub value: OptionValue,
}

impl<T: PartialEq> OptionWithValue<T> {
    /// Merge current option with another if we can, return true if we succeeded
    pub(crate) fn merge(&mut self, other: &Self) -> bool {
        if self.name == other.name {
            match (&mut self.value, &other.value) {
                (
                    OptionValue::List(ListOptionValue {
                        values,
                        value_if_empty,
                        option_prefix,
                        elem_prefix,
                        repeat_option,
                        mode,
                        mergeable_paths,
                    }),
                    OptionValue::List(ListOptionValue {
                        values: ovalues,
                        value_if_empty: ovalue_if_empty,
                        option_prefix: ooption_prefix,
                        elem_prefix: oelem_prefix,
                        repeat_option: orepeat_option,
                        mode: omode,
                        mergeable_paths: omergeable_paths,
                    }),
                ) if value_if_empty == ovalue_if_empty
                    && option_prefix == ooption_prefix
                    && elem_prefix == oelem_prefix
                    && repeat_option == orepeat_option
                    && mode == omode
                    && mergeable_paths == omergeable_paths =>
                {
                    values.extend(ovalues.iter().cloned());
                    values.sort_unstable();
                    true
                }
                _ => false,
            }
        } else {
            false
        }
    }
}

impl FromStr for OptionWithValue<String> {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (name, value) = s
            .split_once('=')
            .ok_or_else(|| anyhow::anyhow!("Missing '=' char in {s:?}"))?;

        Ok(Self {
            name: name.to_owned(),
            #[expect(clippy::unwrap_used)] // never fails
            value: value.parse().unwrap(),
        })
    }
}

impl<T: fmt::Display> fmt::Display for OptionWithValue<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            OptionValue::Boolean(value) => {
                write!(f, "{}={}", self.name, if *value { "true" } else { "false" })
            }
            OptionValue::String(value) => write!(f, "{}={}", self.name, value),
            OptionValue::List(ListOptionValue {
                values,
                value_if_empty,
                option_prefix,
                elem_prefix,
                repeat_option,
                ..
            }) => {
                if values.is_empty() {
                    write!(f, "{}=", self.name)?;
                    if let Some(value_if_empty) = value_if_empty {
                        write!(f, "{value_if_empty}")
                    } else {
                        unreachable!()
                    }
                } else if *repeat_option {
                    for (i, value) in values.iter().enumerate() {
                        write!(f, "{}={}{}{}", self.name, option_prefix, elem_prefix, value)?;
                        if i < values.len() - 1 {
                            writeln!(f)?;
                        }
                    }
                    Ok(())
                } else {
                    write!(
                        f,
                        "{}={}{}",
                        self.name,
                        option_prefix,
                        values
                            .iter()
                            .map(|v| format!("{elem_prefix}{v}"))
                            .collect::<Vec<_>>()
                            .join(" ")
                    )
                }
            }
        }
    }
}

// Syscall groups generated at build time
include!(concat!(env!("OUT_DIR"), "/systemd_syscall_groups.rs"));

pub(crate) fn merge_similar_paths(
    paths: &[PathBuf],
    simplify_threshold: Option<NonZeroUsize>,
) -> Vec<PathBuf> {
    match simplify_threshold {
        Some(simplify_threshold) if paths.len() > simplify_threshold.get() => {
            let mut children: HashMap<PathBuf, HashSet<PathBuf>> = HashMap::new();
            for path in paths {
                let ancestors: Vec<_> = path.ancestors().map(Path::to_path_buf).collect();
                let mut parent: Option<PathBuf> = None;
                for dir in ancestors.into_iter().rev() {
                    if let Some(parent) = parent.as_ref() {
                        children
                            .entry(parent.to_owned())
                            .or_default()
                            .insert(dir.clone());
                    }
                    parent = Some(dir);
                }
            }
            let initial_candidates = vec![PathBuf::from("/")];
            let mut candidates = initial_candidates.clone();
            loop {
                let mut advancing = false;
                let mut new_candidates = Vec::with_capacity(candidates.len());
                for candidate in &candidates {
                    match children.get(candidate) {
                        Some(candidate_children) if !paths.contains(candidate) => {
                            new_candidates.extend(candidate_children.iter().cloned());
                            advancing |= !candidate_children.is_empty();
                        }
                        _ => {
                            new_candidates.push(candidate.to_owned());
                        }
                    }
                }
                // Bail out if:
                // not progressing anymore (paths don't have children)
                if !advancing
                // previous candidate count were lower, and new one is above threshold
                || ((new_candidates.len() > simplify_threshold.get())
                    && (candidates.len() < new_candidates.len())
                    && (candidates != initial_candidates))
                // not less path than initial input
                || (new_candidates.len() >= paths.len())
                {
                    break;
                }
                candidates = new_candidates;
            }
            if candidates == initial_candidates {
                paths.to_vec()
            } else {
                candidates.sort_unstable();
                candidates
            }
        }
        _ => {
            let mut paths: Vec<_> = paths
                .iter()
                .filter(|e| !paths.iter().any(|oe| *e != oe && e.starts_with(oe)))
                .cloned()
                .collect();
            paths.sort_unstable();
            paths
        }
    }
}

fn action_path_exception(action_path: PathBuf) -> PathBuf {
    if action_path
        .symlink_metadata()
        .is_ok_and(|m| m.file_type().is_symlink())
    {
        // systemd follows symlinks, so won't bind mount the symlink,
        // add exception for parent instead
        action_path
            .parent()
            .map(Path::to_path_buf)
            .unwrap_or(action_path)
    } else {
        action_path
    }
}

/// Context passed to option builders to determine which options are enabled
pub(crate) struct OptionContext<'a> {
    pub systemd_version: &'a SystemdVersion,
    pub kernel_version: &'a KernelVersion,
    pub sysctl_state: &'a sysctl::State,
    pub instance_kind: &'a systemd::InstanceKind,
    pub hardening_opts: &'a HardeningOptions,
}

impl OptionContext<'_> {
    fn is_system_instance(&self) -> bool {
        matches!(self.instance_kind, systemd::InstanceKind::System)
    }

    fn can_use_namespaces(&self) -> bool {
        self.is_system_instance() || self.sysctl_state.kernel_unprivileged_userns_clone
    }

    fn systemd_min_version(&self, major: u16, minor: u16) -> bool {
        *self.systemd_version >= SystemdVersion::new(major, minor)
    }

    fn kernel_min_version(&self, major: u16, minor: u16, patch: u16) -> bool {
        *self.kernel_version >= KernelVersion::new(major, minor, patch)
    }
}

/// Specification for a systemd option that can be conditionally enabled
struct OptionSpec {
    enabled_if: fn(&OptionContext<'_>) -> bool,
    build: fn(&OptionContext<'_>) -> OptionDescription,
}

fn always_enabled(_: &OptionContext<'_>) -> bool {
    true
}

//
// Warning: options values must be ordered from less to most restrictive
//

// Options model does not aim to accurately define the option's effects, it is often an oversimplification.
// However the model should always tend to make options *more* (or equally as) restrictive than what they really are,
// as to avoid suggesting options that might break execution.

// TODO APPROXIMATION
// Some options implicitly force NoNewPrivileges=true which has some effects in itself,
// which we need to model

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectSystem=
fn build_protect_system(_ctx: &OptionContext<'_>) -> OptionDescription {
    let mut protect_system_yes_nowrite: Vec<_> = [
        "/usr/", "/boot/", "/efi/", "/lib/", "/lib64/", "/bin/", "/sbin/",
    ]
    .iter()
    .map(|p| OptionValueEffect::DenyWrite(PathDescription::base(p)))
    .collect();
    let mut protect_system_full_nowrite = protect_system_yes_nowrite.clone();
    protect_system_full_nowrite.push(OptionValueEffect::DenyWrite(PathDescription::base("/etc/")));
    protect_system_yes_nowrite.push(OptionValueEffect::DenyAction(ProgramAction::MountToHost));
    protect_system_full_nowrite.push(OptionValueEffect::DenyAction(ProgramAction::MountToHost));
    OptionDescription {
        name: "ProtectSystem",
        possible_values: vec![
            OptionValueDescription {
                value: OptionValue::Boolean(true),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(protect_system_yes_nowrite)),
            },
            OptionValueDescription {
                value: OptionValue::String("full".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    protect_system_full_nowrite,
                )),
            },
            OptionValueDescription {
                value: OptionValue::String("strict".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenyWrite(PathDescription::Base {
                        base: "/".into(),
                        exceptions: vec!["/dev/".into(), "/proc/".into(), "/sys/".into()],
                    }),
                    OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                ])),
            },
        ],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectHome=
fn build_protect_home(_ctx: &OptionContext<'_>) -> OptionDescription {
    let home_paths = ["/home/", "/root/", "/run/user/"];
    OptionDescription {
        name: "ProtectHome",
        possible_values: vec![
            OptionValueDescription {
                value: OptionValue::String("tmpfs".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::EmptyPath(EmptyPathDescription::base(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
            OptionValueDescription {
                value: OptionValue::String("read-only".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::EmptyPath(EmptyPathDescription::base_ro(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
            OptionValueDescription {
                value: OptionValue::Boolean(true),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::RemovePath(PathDescription::base(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
        ],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#PrivateTmp=
fn build_private_tmp(ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateTmp",
        possible_values: vec![OptionValueDescription {
            value: if ctx.systemd_min_version(257, 0) {
                OptionValue::String("disconnected".into())
            } else {
                OptionValue::Boolean(true)
            },
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::EmptyPath(EmptyPathDescription::base("/tmp")),
                OptionValueEffect::EmptyPath(EmptyPathDescription::base("/var/tmp")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#PrivateDevices=
fn build_private_devices(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateDevices",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::EmptyPath(EmptyPathDescription {
                    base: "/dev/".into(),
                    base_ro: true,
                    exceptions_ro: vec![],
                    exceptions_rw: [
                        "null",
                        "zero",
                        "full",
                        "random",
                        "urandom",
                        "tty",
                        "pts/",
                        "ptmx",
                        "shm/",
                        "mqueue/",
                        "hugepages/",
                        "log",
                    ]
                    .iter()
                    .map(|p| PathBuf::from("/dev/").join(p))
                    .collect(),
                }),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("raw-io")),
                OptionValueEffect::DenyAction(ProgramAction::MknodSpecial),
                OptionValueEffect::DenyExec(PathDescription::base("/dev")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#PrivateMounts=
fn build_private_mounts(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateMounts",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(ProgramAction::MountToHost)),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectKernelTunables=
fn build_protect_kernel_tunables(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelTunables",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                [
                    "acpi/",
                    "apm",
                    "asound/",
                    "bus/",
                    "fs/",
                    "irq/",
                    "latency_stats",
                    "mttr",
                    "scsi/",
                    "sys/",
                    "sysrq-trigger",
                    "timer_stats",
                ]
                .iter()
                .map(|p| {
                    OptionValueEffect::DenyWrite(PathDescription::Base {
                        base: PathBuf::from("/proc/").join(p),
                        exceptions: vec![],
                    })
                })
                .chain(["kallsyms", "kcore"].iter().map(|p| {
                    OptionValueEffect::RemovePath(PathDescription::Base {
                        base: PathBuf::from("/proc/").join(p),
                        exceptions: vec![],
                    })
                }))
                .chain(iter::once(OptionValueEffect::DenyWrite(
                    PathDescription::base("/sys"),
                )))
                .chain(iter::once(OptionValueEffect::DenyAction(
                    ProgramAction::MountToHost,
                )))
                .collect(),
            )),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectKernelModules=
fn build_protect_kernel_modules(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelModules",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::base("/lib/modules/")),
                OptionValueEffect::RemovePath(PathDescription::base("/usr/lib/modules/")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("module")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectKernelLogs=
fn build_protect_kernel_logs(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelLogs",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::base("/proc/kmsg")),
                OptionValueEffect::RemovePath(PathDescription::base("/dev/kmsg")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("syslog")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectControlGroups=
fn build_protect_control_groups(_ctx: &OptionContext<'_>) -> OptionDescription {
    // TODO private/strip
    OptionDescription {
        name: "ProtectControlGroups",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::base("/sys/fs/cgroup/")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectProc=
// https://github.com/systemd/systemd/blob/v247/NEWS#L342
// https://github.com/systemd/systemd/commit/4e39995371738b04d98d27b0d34ea8fe09ec9fab
// https://docs.kernel.org/filesystems/proc.html#mount-options
fn build_protect_proc(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectProc",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("ptraceable".to_owned()),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::pattern("^/proc/[0-9]+(/|$)")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProcSubset=
fn build_proc_subset(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProcSubset",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("pid".to_owned()),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::pattern(
                    "^/proc/[^/]*[^0-9/]+[^/]*",
                )),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#LockPersonality=
fn build_lock_personality(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "LockPersonality",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            // In practice, the option allows the call if the default personality is set, but we don't
            // need to model that level of precision.
            // The "deny" model prevents false positives
            desc: OptionEffect::Simple(OptionValueEffect::DenySyscalls(DenySyscalls::Single(
                "personality",
            ))),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RestrictRealtime=
fn build_restrict_realtime(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "RestrictRealtime",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::SetRealtimeScheduler,
            )),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#ProtectClock=
fn build_protect_clock(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectClock",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::pattern("/dev/rtc.*")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("stime")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("clock")),
                OptionValueEffect::DenyAction(ProgramAction::SetAlarm),
            ])),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#MemoryDenyWriteExecute=
// https://github.com/systemd/systemd/blob/v254/src/shared/seccomp-util.c#L1721
fn build_memory_deny_write_execute(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "MemoryDenyWriteExecute",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::WriteExecuteMemoryMapping,
            )),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallArchitectures=
fn build_system_call_architectures(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "SystemCallArchitectures",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("native".to_owned()),
            desc: OptionEffect::None,
        }],
        updater: None,
    }
}

/// Address families for `RestrictAddressFamilies` and `CapabilityBoundingSet`
const ADDRESS_FAMILIES: &[&str] = &[
    // curl https://man7.org/linux/man-pages/man7/address_families.7.html | grep -o 'AF_[A-Za-z0-9]*' | sort -u | xargs -I'{}' echo \"'{}'\",
    "AF_ALG",
    "AF_APPLETALK",
    "AF_ATMPVC",
    "AF_ATMSVC",
    "AF_AX25",
    "AF_BLUETOOTH",
    "AF_BRIDGE",
    "AF_CAIF",
    "AF_CAN",
    "AF_DECnet",
    "AF_ECONET",
    "AF_IB",
    "AF_IEEE802154",
    "AF_INET",
    "AF_INET6",
    "AF_IPX",
    "AF_IRDA",
    "AF_ISDN",
    "AF_IUCV",
    "AF_KCM",
    "AF_KEY",
    "AF_LLC",
    "AF_LOCAL",
    "AF_MPLS",
    "AF_NETBEUI",
    "AF_NETLINK",
    "AF_NETROM",
    "AF_PACKET",
    "AF_PHONET",
    "AF_PPPOX",
    "AF_QIPCRTR",
    "AF_RDS",
    "AF_ROSE",
    "AF_RXRPC",
    "AF_SECURITY",
    "AF_SMC",
    "AF_TIPC",
    "AF_UNIX",
    "AF_VSOCK",
    "AF_WANPIPE",
    "AF_X25",
    "AF_XDP",
];

// https://www.freedesktop.org/software/systemd/man/systemd.exec.html#PrivateNetwork=
//
// For now we enable this option if no sockets are used at all, in theory this could break if
// a socket file descriptor is passed to it from another process.
// Although this is probably a very rare/niche case, it is possible, so we consider it only in aggressive mode
fn build_private_network(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateNetwork",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::NetworkActivity(
                    NetworkActivity {
                        af: SetSpecifier::All,
                        proto: SetSpecifier::All,
                        kind: SetSpecifier::All,
                        local_port: SetSpecifier::All,
                        address: SetSpecifier::All,
                    }
                    .into(),
                ),
            )),
        }],
        updater: None,
    }
}

// https://www.freedesktop.org/software/systemd/man/systemd.resource-control.html#SocketBindAllow=bind-rule
fn build_read_only_paths(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ReadOnlyPaths",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: vec!["/".to_owned()],
                value_if_empty: None,
                option_prefix: "",
                elem_prefix: "-",
                repeat_option: false,
                mode: ListMode::BlackList,
                mergeable_paths: true,
            }),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::base("/")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: Some(OptionUpdater {
            effect: |effect, action, _| {
                let action_path = match action {
                    ProgramAction::Write(action_path) => action_path.to_owned(),
                    ProgramAction::Create(action_path) => action_path.parent()?.to_owned(),
                    _ => return None,
                };
                match effect {
                    OptionValueEffect::DenyWrite(PathDescription::Base { base, exceptions })
                        if action_path != Path::new("/") =>
                    {
                        let mut new_exceptions = Vec::with_capacity(exceptions.len() + 1);
                        new_exceptions.extend(exceptions.iter().cloned());
                        new_exceptions.push(action_path);
                        Some(OptionValueEffect::DenyWrite(PathDescription::Base {
                            base: base.to_owned(),
                            exceptions: new_exceptions,
                        }))
                    }
                    _ => None,
                }
            },
            options: |effect| match effect {
                OptionValueEffect::DenyWrite(PathDescription::Base { base, exceptions }) => {
                    vec![
                        OptionWithValue {
                            name: "ReadOnlyPaths",
                            value: OptionValue::List(ListOptionValue {
                                #[expect(clippy::unwrap_used)]
                                values: vec![base.to_str().unwrap().to_owned()],
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::BlackList,
                                mergeable_paths: true,
                            }),
                        },
                        OptionWithValue {
                            name: "ReadWritePaths",
                            value: OptionValue::List(ListOptionValue {
                                values: merge_similar_paths(exceptions, None)
                                    .iter()
                                    .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                    .collect(),
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::WhiteList,
                                mergeable_paths: true,
                            }),
                        },
                    ]
                }
                OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                    vec![OptionWithValue {
                        name: "PrivateMounts",
                        value: OptionValue::Boolean(true),
                    }]
                }
                _ => unreachable!(),
            },
            dynamic_option_names: Vec::from(["PrivateMounts", "ReadOnlyPaths", "ReadWritePaths"]),
        }),
    }
}

fn build_inaccessible_paths(_ctx: &OptionContext<'_>) -> OptionDescription {
    let mut possible_values = vec![OptionValueDescription {
        value: OptionValue::List(ListOptionValue {
            values: vec!["/".to_owned()],
            value_if_empty: None,
            option_prefix: "",
            elem_prefix: "-",
            repeat_option: false,
            mode: ListMode::BlackList,
            mergeable_paths: true,
        }),
        desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
            OptionValueEffect::RemovePath(PathDescription::base("/")),
            OptionValueEffect::DenyAction(ProgramAction::MountToHost),
        ])),
    }];
    // To avoid InaccessiblePaths being completely disabled simply because of the equivalent of 'ls /',
    // we set another option value for each dir directly under /
    let base_paths: Option<Vec<String>> = fs::read_dir("/")
        .ok()
        .and_then(|i| i.collect::<Result<Vec<_>, _>>().ok())
        .and_then(|v| {
            // Don't make those inaccessible, systemd won't be able to start anything
            let excluded_run_dirs = [Path::new("/run"), Path::new("/proc")];
            v.into_iter()
                .filter(|e| !excluded_run_dirs.contains(&e.path().as_ref()))
                // systemd follows symlinks when applying option, so exclude them
                .filter(|e| e.file_type().is_ok_and(|t| !t.is_symlink()))
                .map(|e| e.path().to_str().map(ToOwned::to_owned))
                .collect()
        })
        .map(|mut v: Vec<_>| {
            v.sort_unstable();
            v
        });
    if let Some(base_paths) = base_paths {
        possible_values.insert(
            0,
            OptionValueDescription {
                value: OptionValue::List(ListOptionValue {
                    values: base_paths.clone(),
                    value_if_empty: None,
                    option_prefix: "",
                    elem_prefix: "-",
                    repeat_option: false,
                    mode: ListMode::BlackList,
                    mergeable_paths: true,
                }),
                desc: OptionEffect::Cumulative(
                    base_paths
                        .iter()
                        .map(|p| {
                            OptionValueEffect::Multiple(vec![
                                OptionValueEffect::RemovePath(PathDescription::base(p)),
                                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                            ])
                        })
                        .collect(),
                ),
            },
        );
    }
    OptionDescription {
        name: "InaccessiblePaths",
        possible_values,
        updater: Some(OptionUpdater {
            effect: |effect, action, _| {
                let (action_path, action_ro) = match action {
                    ProgramAction::Read(action_path) | ProgramAction::Exec(action_path) => {
                        (action_path.to_owned(), true)
                    }
                    ProgramAction::Write(action_path) => (action_path.to_owned(), false),
                    ProgramAction::Create(action_path) => {
                        (action_path.parent().map(Path::to_path_buf)?, false)
                    }
                    _ => return None,
                };
                match effect {
                    OptionValueEffect::RemovePath(PathDescription::Base { base, exceptions }) => {
                        // This will be reached only when first transforming an initial InaccessiblePaths option (RemovePath) into
                        // less restrictive EmptyPaths + exceptions
                        assert!(exceptions.is_empty());
                        let new_exception_path = action_path_exception(action_path);
                        if base.starts_with(&new_exception_path) {
                            return None;
                        }
                        let (exceptions_ro, exceptions_rw) = if action_ro {
                            (vec![new_exception_path], vec![])
                        } else {
                            (vec![], vec![new_exception_path])
                        };
                        Some(OptionValueEffect::EmptyPath(EmptyPathDescription {
                            base: base.to_owned(),
                            base_ro: true,
                            exceptions_ro,
                            exceptions_rw,
                        }))
                    }
                    OptionValueEffect::EmptyPath(EmptyPathDescription {
                        base,
                        base_ro,
                        exceptions_ro,
                        exceptions_rw,
                    }) => {
                        let mut new_exceptions_ro =
                            Vec::with_capacity(exceptions_ro.len() + usize::from(action_ro));
                        new_exceptions_ro.extend(exceptions_ro.iter().cloned());
                        let mut new_exceptions_rw =
                            Vec::with_capacity(exceptions_rw.len() + usize::from(!action_ro));
                        new_exceptions_rw.extend(exceptions_rw.iter().cloned());
                        let mut base_ro = *base_ro;
                        let new_exception_path = action_path_exception(action_path);
                        if matches!(action, ProgramAction::Create(_)) && new_exception_path == *base
                        {
                            base_ro = false;
                        } else {
                            if base.starts_with(&new_exception_path) {
                                return None;
                            }
                            if action_ro {
                                new_exceptions_ro.push(new_exception_path);
                            } else {
                                new_exceptions_rw.push(new_exception_path);
                            }
                        }
                        // Remove exceptions in ro list if in rw
                        new_exceptions_ro.retain(|ero| {
                            !new_exceptions_rw.iter().any(|erw| ero.starts_with(erw))
                        });
                        Some(OptionValueEffect::EmptyPath(EmptyPathDescription {
                            base: base.to_owned(),
                            base_ro,
                            exceptions_ro: new_exceptions_ro,
                            exceptions_rw: new_exceptions_rw,
                        }))
                    }
                    _ => None,
                }
            },
            options: |effect| match effect {
                OptionValueEffect::EmptyPath(EmptyPathDescription {
                    base,
                    base_ro,
                    exceptions_ro,
                    exceptions_rw,
                }) => {
                    // TemporayFileSystem nullifies ReadOnlyPaths, so we must apply read only restrictions here too
                    let mut new_opts = Vec::with_capacity(
                        1 + usize::from(!exceptions_ro.is_empty())
                            + usize::from(!exceptions_rw.is_empty()),
                    );
                    new_opts.push(OptionWithValue {
                        name: "TemporaryFileSystem",
                        value: OptionValue::List(ListOptionValue {
                            #[expect(clippy::unwrap_used)]
                            values: vec![if *base_ro {
                                format!("{}:ro", base.to_str().unwrap())
                            } else {
                                base.to_str().unwrap().to_owned()
                            }],
                            value_if_empty: None,
                            option_prefix: "",
                            elem_prefix: "",
                            repeat_option: false,
                            mode: ListMode::BlackList,
                            mergeable_paths: true,
                        }),
                    });
                    let merged_exceptions_ro: Vec<_> = {
                        let merged_paths = merge_similar_paths(exceptions_ro, None);
                        if merged_paths.iter().any(|p| *base_ro && (p == base)) {
                            // The exception nullifies the option, bail out
                            return vec![];
                        }
                        merged_paths
                            .into_iter()
                            .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                            .collect()
                    };
                    if !merged_exceptions_ro.is_empty() {
                        new_opts.push(OptionWithValue {
                            name: "BindReadOnlyPaths",
                            value: OptionValue::List(ListOptionValue {
                                values: merged_exceptions_ro,
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::WhiteList,
                                mergeable_paths: true,
                            }),
                        });
                    }
                    let merged_exceptions_rw: Vec<_> = {
                        let merged_paths = merge_similar_paths(exceptions_rw, None);
                        if merged_paths.iter().any(|p| p == base) {
                            // The exception nullifies the option, bail out
                            return vec![];
                        }
                        merged_paths
                            .into_iter()
                            .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                            .collect()
                    };
                    if !merged_exceptions_rw.is_empty() {
                        new_opts.push(OptionWithValue {
                            name: "BindPaths",
                            value: OptionValue::List(ListOptionValue {
                                values: merged_exceptions_rw,
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::WhiteList,
                                mergeable_paths: true,
                            }),
                        });
                    }
                    new_opts
                }
                OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                    vec![OptionWithValue {
                        name: "PrivateMounts",
                        value: OptionValue::Boolean(true),
                    }]
                }
                #[expect(clippy::unwrap_used)]
                OptionValueEffect::RemovePath(PathDescription::Base { base, exceptions }) => {
                    assert!(exceptions.is_empty());
                    vec![OptionWithValue {
                        name: "InaccessiblePaths",
                        value: OptionValue::List(ListOptionValue {
                            values: vec![base.to_str().unwrap().to_owned()],
                            value_if_empty: None,
                            option_prefix: "",
                            elem_prefix: "-",
                            repeat_option: false,
                            mode: ListMode::BlackList,
                            mergeable_paths: true,
                        }),
                    }]
                }
                _ => unreachable!(),
            },
            dynamic_option_names: Vec::from([
                "PrivateMounts",
                "TemporaryFileSystem",
                "BindReadOnlyPaths",
                "BindPaths",
            ]),
        }),
    }
}

fn build_no_exec_paths(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "NoExecPaths",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: vec!["/".to_owned()],
                value_if_empty: None,
                option_prefix: "",
                elem_prefix: "-",
                repeat_option: false,
                mode: ListMode::BlackList,
                mergeable_paths: true,
            }),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyExec(PathDescription::base("/")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: Some(OptionUpdater {
            effect: |effect, action, _| {
                let ProgramAction::Exec(action_path) = action else {
                    return None;
                };
                match effect {
                    OptionValueEffect::DenyExec(PathDescription::Base { base, exceptions })
                        if action_path != Path::new("/") =>
                    {
                        let mut new_exceptions = Vec::with_capacity(exceptions.len() + 1);
                        new_exceptions.extend(exceptions.iter().cloned());
                        new_exceptions.push(action_path.to_owned());
                        Some(OptionValueEffect::DenyExec(PathDescription::Base {
                            base: base.to_owned(),
                            exceptions: new_exceptions,
                        }))
                    }
                    _ => None,
                }
            },
            options: |effect| match effect {
                OptionValueEffect::DenyExec(PathDescription::Base { base, exceptions }) => {
                    vec![
                        OptionWithValue {
                            name: "NoExecPaths",
                            value: OptionValue::List(ListOptionValue {
                                #[expect(clippy::unwrap_used)]
                                values: vec![base.to_str().unwrap().to_owned()],
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::BlackList,
                                mergeable_paths: true,
                            }),
                        },
                        OptionWithValue {
                            name: "ExecPaths",
                            value: OptionValue::List(ListOptionValue {
                                values: merge_similar_paths(exceptions, None)
                                    .iter()
                                    .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                    .collect(),
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "-",
                                repeat_option: false,
                                mode: ListMode::WhiteList,
                                mergeable_paths: true,
                            }),
                        },
                    ]
                }
                OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                    vec![OptionWithValue {
                        name: "PrivateMounts",
                        value: OptionValue::Boolean(true),
                    }]
                }
                _ => unreachable!(),
            },
            dynamic_option_names: Vec::from(["NoExecPaths", "PrivateMounts", "ExecPaths"]),
        }),
    }
}

fn build_restrict_address_families(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "RestrictAddressFamilies",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: ADDRESS_FAMILIES.iter().map(|s| (*s).to_owned()).collect(),
                value_if_empty: Some("none"),
                option_prefix: "",
                elem_prefix: "",
                repeat_option: false,
                mode: ListMode::WhiteList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(
                ADDRESS_FAMILIES
                    .iter()
                    .map(|af| {
                        OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                            NetworkActivity {
                                #[expect(clippy::unwrap_used)]
                                af: SetSpecifier::One(af.parse().unwrap()),
                                proto: SetSpecifier::All,
                                kind: SetSpecifier::All,
                                local_port: SetSpecifier::All,
                                address: SetSpecifier::All,
                            }
                            .into(),
                        ))
                    })
                    .collect(),
            ),
        }],
        updater: None,
    }
}

fn build_socket_bind_deny(ctx: &OptionContext<'_>) -> OptionDescription {
    let deny_binds: Vec<_> = SocketFamily::iter()
        .take(2)
        .cartesian_product(SocketProtocol::iter().take(2))
        .collect();
    OptionDescription {
        name: "SocketBindDeny",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: deny_binds
                    .iter()
                    .map(|(af, proto)| format!("{af}:{proto}"))
                    .collect(),
                value_if_empty: None,
                option_prefix: "",
                elem_prefix: "",
                repeat_option: true,
                mode: ListMode::BlackList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(
                deny_binds
                    .into_iter()
                    .map(|(af, proto)| {
                        OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                            NetworkActivity {
                                af: SetSpecifier::One(af),
                                proto: SetSpecifier::One(proto),
                                kind: SetSpecifier::One(NetworkActivityKind::Bind),
                                local_port: SetSpecifier::All,
                                address: SetSpecifier::All,
                            }
                            .into(),
                        ))
                    })
                    .collect(),
            ),
        }],
        updater: ctx
            .hardening_opts
            .network_firewalling
            .then_some(OptionUpdater {
                effect: |e, a, _| {
                    let OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(effect_na)) =
                        e
                    else {
                        return None;
                    };
                    let local_port = if let ProgramAction::NetworkActivity(na) = a {
                        if let SetSpecifier::One(local_port) = &na.as_ref().local_port {
                            local_port
                        } else {
                            return None;
                        }
                    } else {
                        return None;
                    };
                    let mut new_eff_local_port = effect_na.local_port.clone();
                    new_eff_local_port.remove(local_port);
                    Some(OptionValueEffect::DenyAction(
                        ProgramAction::NetworkActivity(
                            NetworkActivity {
                                af: effect_na.af.clone(),
                                proto: effect_na.proto.clone(),
                                kind: effect_na.kind.clone(),
                                local_port: new_eff_local_port,
                                address: effect_na.address.clone(),
                            }
                            .into(),
                        ),
                    ))
                },
                options: |e| {
                    let (af, proto, local_port) = if let OptionValueEffect::DenyAction(
                        ProgramAction::NetworkActivity(na),
                    ) = e
                    {
                        if let NetworkActivity {
                            af: SetSpecifier::One(af),
                            proto: SetSpecifier::One(proto),
                            local_port,
                            ..
                        } = na.as_ref()
                        {
                            (af, proto, local_port)
                        } else {
                            unreachable!()
                        }
                    } else {
                        unreachable!();
                    };
                    let port_exceptions = local_port.excluded_elements();
                    let mut opts = Vec::with_capacity(1 + port_exceptions.len());
                    opts.push(OptionWithValue {
                        name: "SocketBindDeny",
                        value: OptionValue::String(format!("{af}:{proto}")),
                    });
                    opts.extend(
                        port_exceptions
                            .iter()
                            .map(|port_exception| OptionWithValue {
                                name: "SocketBindAllow",
                                value: OptionValue::String(format!(
                                    "{af}:{proto}:{port_exception}"
                                )),
                            }),
                    );
                    opts
                },
                dynamic_option_names: Vec::from(["SocketBindDeny"]),
            }),
    }
}

fn build_ip_address_deny(_ctx: &OptionContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "IPAddressDeny",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("any".into()),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::NetworkActivity(
                    NetworkActivity {
                        af: SetSpecifier::Some(vec![SocketFamily::Ipv4, SocketFamily::Ipv6]),
                        proto: SetSpecifier::All,
                        kind: SetSpecifier::Some(NetworkActivityKind::ADDRESSED.to_vec()),
                        local_port: SetSpecifier::All,
                        address: SetSpecifier::All,
                    }
                    .into(),
                ),
            )),
        }],
        updater: Some(OptionUpdater {
            effect: |effect, action, _| {
                let OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(effect_na)) =
                    effect
                else {
                    return None;
                };
                let action_addr = if let ProgramAction::NetworkActivity(na) = action {
                    if let NetworkActivity {
                        address: SetSpecifier::One(action_addr),
                        ..
                    } = na.as_ref()
                    {
                        action_addr
                    } else {
                        return None;
                    }
                } else {
                    return None;
                };
                let mut new_effect_address = effect_na.address.clone();
                new_effect_address.remove(action_addr);
                Some(OptionValueEffect::DenyAction(
                    ProgramAction::NetworkActivity(
                        NetworkActivity {
                            address: new_effect_address,
                            ..*effect_na.to_owned()
                        }
                        .into(),
                    ),
                ))
            },
            options: |effect| match effect {
                OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(na)) => {
                    let NetworkActivity { address, .. } = na.as_ref();
                    vec![
                        OptionWithValue {
                            name: "IPAddressDeny",
                            value: OptionValue::String("any".into()),
                        },
                        OptionWithValue {
                            name: "IPAddressAllow",
                            value: OptionValue::List(ListOptionValue {
                                values: address
                                    .excluded_elements()
                                    .into_iter()
                                    .map(|e| e.to_string())
                                    .collect(),
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "",
                                repeat_option: false,
                                mode: ListMode::WhiteList,
                                mergeable_paths: false,
                            }),
                        },
                    ]
                }
                _ => unreachable!(),
            },
            dynamic_option_names: vec!["IPAddressDeny", "IPAddressAllow"],
        }),
    }
}

fn build_capability_bounding_set(_ctx: &OptionContext<'_>) -> OptionDescription {
    let cap_effects = [
        (
            "CAP_BLOCK_SUSPEND",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::base("/proc/sys/wake_lock")),
                OptionValueEffect::DenyAction(ProgramAction::Wakeup),
            ]),
        ),
        (
            "CAP_BPF",
            OptionValueEffect::DenySyscalls(DenySyscalls::Single("bpf")),
        ),
        (
            "CAP_CHOWN",
            OptionValueEffect::DenySyscalls(DenySyscalls::Class("chown")),
        ),
        (
            "CAP_IPC_LOCK",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("memlock")),
                OptionValueEffect::DenyAction(ProgramAction::LockMemoryMapping),
                OptionValueEffect::DenyAction(ProgramAction::HugePageMemoryMapping),
            ]),
        ),
        (
            "CAP_KILL",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyAction(ProgramAction::KillOther),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("ioctl")),
            ]),
        ),
        (
            "CAP_MKNOD",
            OptionValueEffect::DenyAction(ProgramAction::MknodSpecial),
        ),
        (
            "CAP_NET_RAW",
            OptionValueEffect::Multiple(
                iter::once(OptionValueEffect::DenyAction(
                    ProgramAction::NetworkActivity(
                        NetworkActivity {
                            af: SetSpecifier::One(SocketFamily::Other("AF_PACKET".into())),
                            proto: SetSpecifier::All,
                            kind: SetSpecifier::All,
                            local_port: SetSpecifier::All,
                            address: SetSpecifier::All,
                        }
                        .into(),
                    ),
                ))
                .chain(
                    ADDRESS_FAMILIES
                        .iter()
                        .filter(|af| **af != "AF_NETLINK")
                        .map(|af| {
                            OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                                NetworkActivity {
                                    #[expect(clippy::unwrap_used)]
                                    af: SetSpecifier::One(af.parse().unwrap()),
                                    proto: SetSpecifier::One(SocketProtocol::Other(
                                        "SOCK_RAW".into(),
                                    )),
                                    kind: SetSpecifier::All,
                                    local_port: SetSpecifier::All,
                                    address: SetSpecifier::All,
                                }
                                .into(),
                            ))
                        }),
                )
                .collect(),
            ),
        ),
        (
            "CAP_PERFMON",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("perf_event_open")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("bpf")),
            ]),
        ),
        (
            "CAP_SYS_BOOT",
            OptionValueEffect::DenySyscalls(DenySyscalls::Class("reboot")),
        ),
        (
            "CAP_SYS_CHROOT",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("chroot")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("setns")),
            ]),
        ),
        (
            "CAP_SYS_MODULE",
            OptionValueEffect::DenySyscalls(DenySyscalls::Class("module")),
        ),
        (
            "CAP_SYS_NICE",
            OptionValueEffect::DenySyscalls(DenySyscalls::Class("resources")),
        ),
        (
            "CAP_SYS_PACCT",
            OptionValueEffect::DenySyscalls(DenySyscalls::Single("acct")),
        ),
        (
            "CAP_SYS_PTRACE",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("ptrace)")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("get_robust_list")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("process_vm_readv")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("process_vm_writev")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("kcmp")),
            ]),
        ),
        (
            "CAP_SYS_TIME",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("clock")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("stime")),
            ]),
        ),
        (
            "CAP_SYS_TTY_CONFIG",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("vhangup")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("ioctl")),
            ]),
        ),
        (
            "CAP_SYSLOG",
            OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("syslog")),
                OptionValueEffect::DenyAction(ProgramAction::Read("/dev/kmsg".into())),
            ]),
        ),
        (
            "CAP_WAKE_ALARM",
            OptionValueEffect::DenyAction(ProgramAction::SetAlarm),
        ),
    ];
    OptionDescription {
        name: "CapabilityBoundingSet",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: cap_effects.iter().map(|(c, _e)| (*c).to_owned()).collect(),
                value_if_empty: None,
                option_prefix: "~",
                elem_prefix: "",
                repeat_option: false,
                mode: ListMode::BlackList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(cap_effects.into_iter().map(|(_c, e)| e).collect()),
        }],
        updater: None,
    }
}

fn build_system_call_filter(_ctx: &OptionContext<'_>) -> OptionDescription {
    let mut syscall_classes: Vec<_> = SYSCALL_CLASSES.keys().copied().collect();
    syscall_classes.sort_unstable();
    OptionDescription {
        name: "SystemCallFilter",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: syscall_classes
                    .iter()
                    .map(|c| format!("@{c}:EPERM"))
                    .collect(),
                value_if_empty: None,
                option_prefix: "~",
                elem_prefix: "",
                repeat_option: false,
                mode: ListMode::BlackList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(
                syscall_classes
                    .into_iter()
                    .map(|class| OptionValueEffect::DenySyscalls(DenySyscalls::Class(class)))
                    .collect(),
            ),
        }],
        updater: None,
    }
}

/// Static registry of option specifications with their enable conditions
static OPTION_SPECS: &[OptionSpec] = &[
    // ProtectSystem - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_protect_system,
    },
    // ProtectHome - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_home,
    },
    // PrivateTmp - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_tmp,
    },
    // PrivateDevices - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_devices,
    },
    // PrivateMounts - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_mounts,
    },
    // ProtectKernelTunables - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_tunables,
    },
    // ProtectKernelModules - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_modules,
    },
    // ProtectKernelLogs - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_logs,
    },
    // ProtectControlGroups - system instance only
    OptionSpec {
        enabled_if: |ctx| ctx.is_system_instance(),
        build: build_protect_control_groups,
    },
    // ProtectProc - system instance, systemd >= 247, kernel >= 5.8
    OptionSpec {
        enabled_if: |ctx| {
            ctx.is_system_instance()
                && ctx.systemd_min_version(247, 0)
                && ctx.kernel_min_version(5, 8, 0)
        },
        build: build_protect_proc,
    },
    // ProcSubset - system instance, systemd >= 247, kernel >= 5.8
    OptionSpec {
        enabled_if: |ctx| {
            ctx.is_system_instance()
                && ctx.systemd_min_version(247, 0)
                && ctx.kernel_min_version(5, 8, 0)
        },
        build: build_proc_subset,
    },
    // LockPersonality - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_lock_personality,
    },
    // RestrictRealtime - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_restrict_realtime,
    },
    // ProtectClock - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_clock,
    },
    // MemoryDenyWriteExecute - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_memory_deny_write_execute,
    },
    // SystemCallArchitectures - aggressive mode only
    OptionSpec {
        enabled_if: |ctx| matches!(ctx.hardening_opts.mode, HardeningMode::Aggressive),
        build: build_system_call_architectures,
    },
    // PrivateNetwork - namespaces + aggressive mode
    OptionSpec {
        enabled_if: |ctx| {
            ctx.can_use_namespaces() && matches!(ctx.hardening_opts.mode, HardeningMode::Aggressive)
        },
        build: build_private_network,
    },
    // ReadOnlyPaths - namespaces + filesystem_whitelisting
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces() && ctx.hardening_opts.filesystem_whitelisting,
        build: build_read_only_paths,
    },
    // InaccessiblePaths - namespaces + filesystem_whitelisting
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces() && ctx.hardening_opts.filesystem_whitelisting,
        build: build_inaccessible_paths,
    },
    // NoExecPaths - namespaces + filesystem_whitelisting
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces() && ctx.hardening_opts.filesystem_whitelisting,
        build: build_no_exec_paths,
    },
    // RestrictAddressFamilies - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_restrict_address_families,
    },
    // SocketBindDeny - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_socket_bind_deny,
    },
    // IPAddressDeny - network_firewalling enabled
    OptionSpec {
        enabled_if: |ctx| ctx.hardening_opts.network_firewalling,
        build: build_ip_address_deny,
    },
    // CapabilityBoundingSet - namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_capability_bounding_set,
    },
    // SystemCallFilter - not generic mode
    OptionSpec {
        enabled_if: |ctx| !matches!(ctx.hardening_opts.mode, HardeningMode::Generic),
        build: build_system_call_filter,
    },
];

pub(crate) fn build_options(
    systemd_version: &SystemdVersion,
    kernel_version: &KernelVersion,
    sysctl_state: &sysctl::State,
    instance_kind: &systemd::InstanceKind,
    hardening_opts: &HardeningOptions,
) -> Vec<OptionDescription> {
    let ctx = OptionContext {
        systemd_version,
        kernel_version,
        sysctl_state,
        instance_kind,
        hardening_opts,
    };

    // Build options from the static registry
    let options: Vec<OptionDescription> = OPTION_SPECS
        .iter()
        .filter(|spec| (spec.enabled_if)(&ctx))
        .map(|spec| (spec.build)(&ctx))
        .filter(|desc| {
            ctx.hardening_opts
                .systemd_options
                .as_ref()
                .is_none_or(|whitelist| whitelist.iter().any(|wo| desc.name == wo))
        })
        .collect();

    log::debug!("{options:#?}");
    options
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn merge_similar_paths_works() {
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/ab/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ab/ab3"),
                    PathBuf::from("/a/ab/ab4/abc")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/ab")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a1/ab/ab1"),
                    PathBuf::from("/a2/ab/ab2"),
                    PathBuf::from("/a3/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![
                PathBuf::from("/a1/ab/ab1"),
                PathBuf::from("/a2/ab/ab2"),
                PathBuf::from("/a3/ab/ab3")
            ]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ac/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/aa/ab2"),
                    PathBuf::from("/a/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/aa"), PathBuf::from("/a/ab")]
        );
        for threshold in [2, 5] {
            assert_eq!(
                merge_similar_paths(
                    &[
                        PathBuf::from("/a"),
                        PathBuf::from("/a/b"),
                        PathBuf::from("/a/b/c"),
                        PathBuf::from("/d/b/c"),
                    ],
                    Some(NonZeroUsize::new(threshold).unwrap())
                ),
                vec![PathBuf::from("/a"), PathBuf::from("/d/b/c")]
            );
        }
    }
}
