//! Systemd option model

// Last updated for systemd v257

use std::{
    borrow::ToOwned,
    collections::{HashMap, HashSet},
    fmt, fs,
    io::{self, Write},
    iter,
    num::NonZeroUsize,
    os::unix::ffi::OsStrExt as _,
    path::{Path, PathBuf},
    str::FromStr,
};

use itertools::Itertools as _;
use strum::IntoEnumIterator as _;

use crate::{
    cl::{HardeningMode, HardeningOptions},
    summarize::{NetworkActivity, NetworkActivityKind, ProgramAction, SetSpecifier},
    sysctl,
    systemd::{self, KernelVersion, SystemdVersion},
};

/// Callbacks to dynamically update an option to make it compatible with an action
#[derive(Debug)]
pub(crate) struct OptionUpdater {
    /// Generate a new option effect compatible with the previously incompatible action
    /// If effect contains multiple ones, updater is called once per sub effect
    pub effect:
        fn(&OptionValueEffect, &ProgramAction, &HardeningOptions) -> Option<OptionValueEffect>,
    /// Generate new options from the new effect
    pub options: fn(&OptionValueEffect) -> Vec<OptionWithValue<&'static str>>,
    /// Names of the options that might be generated by the updater (used for markdown option list generation)
    pub dynamic_option_names: Vec<&'static str>,
}

/// Systemd option with its possibles values, and their effect
#[derive(Debug)]
pub(crate) struct OptionDescription {
    pub name: &'static str,
    pub possible_values: Vec<OptionValueDescription>,
    pub updater: Option<OptionUpdater>,
}

impl OptionDescription {
    pub(crate) fn write_markdown<W: Write>(&self, w: &mut W) -> io::Result<()> {
        const MARKDOWN_IDENT: &str = "  ";
        writeln!(
            w,
            "- [`{}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{}=)\n",
            self.name, self.name
        )?;
        for opt_val in &self.possible_values {
            if let OptionValue::List(list) = &opt_val.value {
                writeln!(
                    w,
                    "{}- *dynamic {}{}*",
                    MARKDOWN_IDENT,
                    if list.mergeable_paths { "path " } else { "" },
                    match list.mode {
                        ListMode::BlackList => "blacklisting",
                        ListMode::WhiteList => "whitelisting",
                    }
                )?;
                break;
            }
            match &opt_val.value {
                OptionValue::Boolean(v) => {
                    writeln!(
                        w,
                        "{}- `{}`",
                        MARKDOWN_IDENT,
                        if *v { "true" } else { "false" }
                    )?;
                }
                OptionValue::String(v) => writeln!(w, "{MARKDOWN_IDENT}- `{v}`")?,
                OptionValue::List(ListOptionValue { values, .. }) => {
                    for val in values {
                        writeln!(w, "{MARKDOWN_IDENT}- `{val}`")?;
                    }
                }
            }
        }
        if let Some(updater) = &self.updater {
            let mut first = true;
            for new_opt_name in updater
                .dynamic_option_names
                .iter()
                .filter(|n| **n != self.name)
            {
                if first {
                    writeln!(
                        w,
                        "{MARKDOWN_IDENT}- to support this option, other options may be dynamically enabled:",
                    )?;
                    first = false;
                }
                writeln!(
                    w,
                    "{MARKDOWN_IDENT}{MARKDOWN_IDENT}- [`{new_opt_name}`](https://www.freedesktop.org/software/systemd/man/latest/systemd.directives.html#{new_opt_name}=)"
                )?;
            }
        }
        writeln!(w)
    }
}

impl fmt::Display for OptionDescription {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        self.name.fmt(f)
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash)]
pub(crate) enum ListMode {
    WhiteList,
    BlackList,
}

/// Systemd option value
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) enum OptionValue {
    Boolean(bool), // In most case we only model the 'true' value, because false is no-op and the default
    String(String), // enum-like, or free string
    List(ListOptionValue),
}

#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct ListOptionValue {
    pub values: Vec<String>,
    pub value_if_empty: Option<&'static str>,
    pub option_prefix: &'static str,
    pub elem_prefix: &'static str,
    pub repeat_option: bool,
    pub mode: ListMode,
    pub mergeable_paths: bool,
}

impl FromStr for OptionValue {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "true" => Ok(OptionValue::Boolean(true)),
            "false" => Ok(OptionValue::Boolean(false)),
            _ => Ok(OptionValue::String(s.to_owned())),
        }
    }
}

/// A systemd option value and its effects
#[derive(Debug)]
pub(crate) struct OptionValueDescription {
    pub value: OptionValue,
    pub desc: OptionEffect,
}

/// The effects a systemd option has if enabled
#[derive(Debug, Clone)]
pub(crate) enum OptionEffect {
    /// Option has no modeled effect (it will be unconditionally enabled)
    None,
    /// Option has several mutually exclusive possible values
    Simple(OptionValueEffect),
    /// Option has several possible values, that can be combined to stack effects
    Cumulative(Vec<OptionValueEffect>),
}

#[derive(Debug, Clone)]
pub(crate) enum PathDescription {
    Base {
        base: PathBuf,
        exceptions: Vec<PathBuf>,
    },
    Pattern(regex::bytes::Regex),
}

impl PathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self::Base {
            base: base.into(),
            exceptions: vec![],
        }
    }

    pub(crate) fn pattern(pattern: &'static str) -> Self {
        #[expect(clippy::unwrap_used)]
        Self::Pattern(regex::bytes::Regex::new(pattern).unwrap())
    }

    pub(crate) fn matches(&self, path: &Path) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        match self {
            PathDescription::Base { base, exceptions } => {
                path.starts_with(base) && !exceptions.iter().any(|e| path.starts_with(e))
            }
            PathDescription::Pattern(r) => r.is_match(path.as_os_str().as_bytes()),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) struct EmptyPathDescription {
    /// Base path
    pub base: PathBuf,
    /// Whether base path is read only
    pub base_ro: bool,
    /// Read only paths below base
    pub exceptions_ro: Vec<PathBuf>,
    /// Read/write paths below base
    pub exceptions_rw: Vec<PathBuf>,
}

impl EmptyPathDescription {
    pub(crate) fn base(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: false,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn base_ro(base: &str) -> Self {
        Self {
            base: base.into(),
            base_ro: true,
            exceptions_ro: vec![],
            exceptions_rw: vec![],
        }
    }

    pub(crate) fn matches(&self, path: &Path, ro: bool) -> bool {
        assert!(path.is_absolute(), "{path:?}");
        if !path.starts_with(&self.base) {
            return false;
        }
        if ro {
            !self
                .exceptions_ro
                .iter()
                .chain(&self.exceptions_rw)
                .any(|e| path.starts_with(e))
        } else {
            !self.exceptions_rw.iter().any(|e| path.starts_with(e))
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum OptionValueEffect {
    /// Deny an action
    DenyAction(ProgramAction),
    /// Mount path as noexec
    DenyExec(PathDescription),
    /// Deny syscall(s)
    DenySyscalls(DenySyscalls),
    /// Mount path as read only
    DenyWrite(PathDescription),
    /// Mount an empty tmpfs under given directory
    EmptyPath(EmptyPathDescription),
    /// Union of multiple effects
    Multiple(Vec<OptionValueEffect>),
    /// Don't mount path in target namespace
    RemovePath(PathDescription),
}

impl OptionValueEffect {
    /// Merge current effect with another, while avoiding creating nested `Multiple`
    pub(crate) fn merge(&mut self, other: &OptionValueEffect) {
        match self {
            OptionValueEffect::Multiple(effs) => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    effs.extend(oeffs.iter().cloned());
                }
                oeff => {
                    effs.push(oeff.clone());
                }
            },
            eff => match other {
                OptionValueEffect::Multiple(oeffs) => {
                    let mut new_effs = Vec::with_capacity(oeffs.len() + 1);
                    new_effs.push(eff.to_owned());
                    new_effs.extend(oeffs.iter().cloned());
                    *eff = OptionValueEffect::Multiple(new_effs);
                }
                oeff => {
                    *eff = OptionValueEffect::Multiple(vec![eff.to_owned(), oeff.to_owned()]);
                }
            },
        }
    }

    /// Get an iterator over effects
    pub(crate) fn iter<'a>(&'a self) -> Box<dyn Iterator<Item = &'a Self> + 'a> {
        match self {
            OptionValueEffect::Multiple(effs) => Box::new(effs.iter()),
            _ => Box::new(iter::once(self)),
        }
    }
}

#[derive(Debug, Clone)]
pub(crate) enum DenySyscalls {
    /// See <https://github.com/systemd/systemd/blob/v254/src/shared/seccomp-util.c#L306>
    /// for the content of each class
    Class(&'static str),
    Single(&'static str),
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketFamily {
    Ipv4,
    Ipv6,
    Other(String),
}

impl FromStr for SocketFamily {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "AF_INET" => Ok(Self::Ipv4),
            "AF_INET6" => Ok(Self::Ipv6),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

#[derive(
    Debug,
    Clone,
    Eq,
    PartialEq,
    strum::EnumIter,
    strum::Display,
    serde::Serialize,
    serde::Deserialize,
)]
#[strum(serialize_all = "snake_case")]
pub(crate) enum SocketProtocol {
    Tcp,
    Udp,
    Other(String),
}

impl FromStr for SocketProtocol {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "SOCK_STREAM" => Ok(Self::Tcp),
            "SOCK_DGRAM" => Ok(Self::Udp),
            _ => Ok(Self::Other(s.to_owned())),
        }
    }
}

impl DenySyscalls {
    /// Get denied syscall names
    pub(crate) fn syscalls(&self) -> HashSet<&'static str> {
        match self {
            Self::Class(class) => {
                #[expect(clippy::unwrap_used)]
                let mut content: HashSet<_> = SYSCALL_CLASSES
                    .get(class)
                    .unwrap()
                    .iter()
                    .copied()
                    .collect();
                while content.iter().any(|e| e.starts_with('@')) {
                    content = content
                        .iter()
                        .filter_map(|c| {
                            #[expect(clippy::unwrap_used)]
                            c.strip_prefix('@')
                                .map(|cn| SYSCALL_CLASSES.get(cn).unwrap())
                        })
                        .flatten()
                        .chain(content.iter().filter(|e| !e.starts_with('@')))
                        .copied()
                        .collect();
                }
                content
            }
            Self::Single(sc) => HashSet::from([sc.to_owned()]),
        }
    }
}

/// A systemd option with a value, as would be present in a config file
#[derive(Debug, Clone, Eq, PartialEq, Hash)]
pub(crate) struct OptionWithValue<T> {
    pub name: T,
    pub value: OptionValue,
}

impl<T: PartialEq> OptionWithValue<T> {
    /// Merge current option with another if we can, return true if we succeeded
    pub(crate) fn merge(&mut self, other: &Self) -> bool {
        if self.name == other.name {
            match (&mut self.value, &other.value) {
                (
                    OptionValue::List(ListOptionValue {
                        values,
                        value_if_empty,
                        option_prefix,
                        elem_prefix,
                        repeat_option,
                        mode,
                        mergeable_paths,
                    }),
                    OptionValue::List(ListOptionValue {
                        values: ovalues,
                        value_if_empty: ovalue_if_empty,
                        option_prefix: ooption_prefix,
                        elem_prefix: oelem_prefix,
                        repeat_option: orepeat_option,
                        mode: omode,
                        mergeable_paths: omergeable_paths,
                    }),
                ) if value_if_empty == ovalue_if_empty
                    && option_prefix == ooption_prefix
                    && elem_prefix == oelem_prefix
                    && repeat_option == orepeat_option
                    && mode == omode
                    && mergeable_paths == omergeable_paths =>
                {
                    values.extend(ovalues.iter().cloned());
                    values.sort_unstable();
                    true
                }
                _ => false,
            }
        } else {
            false
        }
    }
}

impl FromStr for OptionWithValue<String> {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let (name, value) = s
            .split_once('=')
            .ok_or_else(|| anyhow::anyhow!("Missing '=' char in {s:?}"))?;

        Ok(Self {
            name: name.to_owned(),
            #[expect(clippy::unwrap_used)] // never fails
            value: value.parse().unwrap(),
        })
    }
}

impl<T: fmt::Display> fmt::Display for OptionWithValue<T> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.value {
            OptionValue::Boolean(value) => {
                write!(f, "{}={}", self.name, if *value { "true" } else { "false" })
            }
            OptionValue::String(value) => write!(f, "{}={}", self.name, value),
            OptionValue::List(ListOptionValue {
                values,
                value_if_empty,
                option_prefix,
                elem_prefix,
                repeat_option,
                ..
            }) => {
                if values.is_empty() {
                    write!(f, "{}=", self.name)?;
                    if let Some(value_if_empty) = value_if_empty {
                        write!(f, "{value_if_empty}")
                    } else {
                        unreachable!()
                    }
                } else if *repeat_option {
                    for (i, value) in values.iter().enumerate() {
                        write!(f, "{}={}{}{}", self.name, option_prefix, elem_prefix, value)?;
                        if i < values.len() - 1 {
                            writeln!(f)?;
                        }
                    }
                    Ok(())
                } else {
                    write!(
                        f,
                        "{}={}{}",
                        self.name,
                        option_prefix,
                        values
                            .iter()
                            .map(|v| format!("{elem_prefix}{v}"))
                            .collect::<Vec<_>>()
                            .join(" ")
                    )
                }
            }
        }
    }
}

// Syscall groups generated at build time
include!(concat!(env!("OUT_DIR"), "/systemd_syscall_groups.rs"));

pub(crate) fn merge_similar_paths(
    paths: &[PathBuf],
    simplify_threshold: Option<NonZeroUsize>,
) -> Vec<PathBuf> {
    match simplify_threshold {
        Some(simplify_threshold) if paths.len() > simplify_threshold.get() => {
            let mut children: HashMap<PathBuf, HashSet<PathBuf>> = HashMap::new();
            for path in paths {
                let ancestors: Vec<_> = path.ancestors().map(Path::to_path_buf).collect();
                let mut parent: Option<PathBuf> = None;
                for dir in ancestors.into_iter().rev() {
                    if let Some(parent) = parent.as_ref() {
                        children
                            .entry(parent.to_owned())
                            .or_default()
                            .insert(dir.clone());
                    }
                    parent = Some(dir);
                }
            }
            let initial_candidates = vec![PathBuf::from("/")];
            let mut candidates = initial_candidates.clone();
            loop {
                let mut advancing = false;
                let mut new_candidates = Vec::with_capacity(candidates.len());
                for candidate in &candidates {
                    match children.get(candidate) {
                        Some(candidate_children) if !paths.contains(candidate) => {
                            new_candidates.extend(candidate_children.iter().cloned());
                            advancing |= !candidate_children.is_empty();
                        }
                        _ => {
                            new_candidates.push(candidate.to_owned());
                        }
                    }
                }
                // Bail out if:
                // not progressing anymore (paths don't have children)
                if !advancing
                // previous candidate count were lower, and new one is above threshold
                || ((new_candidates.len() > simplify_threshold.get())
                    && (candidates.len() < new_candidates.len())
                    && (candidates != initial_candidates))
                // not less path than initial input
                || (new_candidates.len() >= paths.len())
                {
                    break;
                }
                candidates = new_candidates;
            }
            if candidates == initial_candidates {
                paths.to_vec()
            } else {
                candidates.sort_unstable();
                candidates
            }
        }
        _ => {
            let mut paths: Vec<_> = paths
                .iter()
                .filter(|e| !paths.iter().any(|oe| *e != oe && e.starts_with(oe)))
                .cloned()
                .collect();
            paths.sort_unstable();
            paths
        }
    }
}

fn action_path_exception(action_path: PathBuf) -> PathBuf {
    if action_path
        .symlink_metadata()
        .is_ok_and(|m| m.file_type().is_symlink())
    {
        // systemd follows symlinks, so won't bind mount the symlink,
        // add exception for parent instead
        action_path
            .parent()
            .map(Path::to_path_buf)
            .unwrap_or(action_path)
    } else {
        action_path
    }
}

/// Context passed to option builders to determine which options are enabled
pub(crate) struct OptionsContext<'a> {
    pub systemd_version: &'a SystemdVersion,
    pub kernel_version: &'a KernelVersion,
    pub sysctl_state: &'a sysctl::State,
    pub instance_kind: &'a systemd::InstanceKind,
    pub hardening_opts: &'a HardeningOptions,
}

impl OptionsContext<'_> {
    fn is_system_instance(&self) -> bool {
        matches!(self.instance_kind, systemd::InstanceKind::System)
    }

    fn can_use_namespaces(&self) -> bool {
        self.is_system_instance() || self.sysctl_state.kernel_unprivileged_userns_clone
    }

    fn systemd_at_least(&self, major: u16, minor: u16) -> bool {
        *self.systemd_version >= SystemdVersion::new(major, minor)
    }

    fn kernel_at_least(&self, major: u16, minor: u16, patch: u16) -> bool {
        *self.kernel_version >= KernelVersion::new(major, minor, patch)
    }
}

/// Specification for a systemd option that can be conditionally enabled
struct OptionSpec {
    enabled_if: fn(&OptionsContext<'_>) -> bool,
    build: fn(&OptionsContext<'_>) -> OptionDescription,
}

fn always_enabled(_: &OptionsContext<'_>) -> bool {
    true
}

// Builder functions for each option
fn build_protect_system(_ctx: &OptionsContext<'_>) -> OptionDescription {
    let mut protect_system_yes_nowrite: Vec<_> = [
        "/usr/", "/boot/", "/efi/", "/lib/", "/lib64/", "/bin/", "/sbin/",
    ]
    .iter()
    .map(|p| OptionValueEffect::DenyWrite(PathDescription::base(p)))
    .collect();
    let mut protect_system_full_nowrite = protect_system_yes_nowrite.clone();
    protect_system_full_nowrite.push(OptionValueEffect::DenyWrite(PathDescription::base("/etc/")));
    protect_system_yes_nowrite.push(OptionValueEffect::DenyAction(ProgramAction::MountToHost));
    protect_system_full_nowrite.push(OptionValueEffect::DenyAction(ProgramAction::MountToHost));
    OptionDescription {
        name: "ProtectSystem",
        possible_values: vec![
            OptionValueDescription {
                value: OptionValue::Boolean(true),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(protect_system_yes_nowrite)),
            },
            OptionValueDescription {
                value: OptionValue::String("full".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    protect_system_full_nowrite,
                )),
            },
            OptionValueDescription {
                value: OptionValue::String("strict".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenyWrite(PathDescription::Base {
                        base: "/".into(),
                        exceptions: vec!["/dev/".into(), "/proc/".into(), "/sys/".into()],
                    }),
                    OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                ])),
            },
        ],
        updater: None,
    }
}

fn build_protect_home(_ctx: &OptionsContext<'_>) -> OptionDescription {
    let home_paths = ["/home/", "/root/", "/run/user/"];
    OptionDescription {
        name: "ProtectHome",
        possible_values: vec![
            OptionValueDescription {
                value: OptionValue::String("tmpfs".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::EmptyPath(EmptyPathDescription::base(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
            OptionValueDescription {
                value: OptionValue::String("read-only".to_owned()),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::EmptyPath(EmptyPathDescription::base_ro(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
            OptionValueDescription {
                value: OptionValue::Boolean(true),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                    home_paths
                        .iter()
                        .map(|p| OptionValueEffect::RemovePath(PathDescription::base(p)))
                        .chain(iter::once(OptionValueEffect::DenyAction(
                            ProgramAction::MountToHost,
                        )))
                        .collect(),
                )),
            },
        ],
        updater: None,
    }
}

fn build_private_tmp(ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateTmp",
        possible_values: vec![OptionValueDescription {
            value: if ctx.systemd_at_least(257, 0) {
                OptionValue::String("disconnected".into())
            } else {
                OptionValue::Boolean(true)
            },
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::EmptyPath(EmptyPathDescription::base("/tmp")),
                OptionValueEffect::EmptyPath(EmptyPathDescription::base("/var/tmp")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_private_devices(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateDevices",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::EmptyPath(EmptyPathDescription {
                    base: "/dev/".into(),
                    base_ro: true,
                    exceptions_ro: vec![],
                    exceptions_rw: [
                        "null", "zero", "full", "random", "urandom", "tty", "pts/", "ptmx",
                        "shm/", "mqueue/", "hugepages/", "log",
                    ]
                    .iter()
                    .map(|p| PathBuf::from("/dev/").join(p))
                    .collect(),
                }),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("raw-io")),
                OptionValueEffect::DenyAction(ProgramAction::MknodSpecial),
                OptionValueEffect::DenyExec(PathDescription::base("/dev")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_private_mounts(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateMounts",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(ProgramAction::MountToHost)),
        }],
        updater: None,
    }
}

fn build_protect_kernel_tunables(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelTunables",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(
                [
                    "acpi/",
                    "apm",
                    "asound/",
                    "bus/",
                    "fs/",
                    "irq/",
                    "latency_stats",
                    "mttr",
                    "scsi/",
                    "sys/",
                    "sysrq-trigger",
                    "timer_stats",
                ]
                .iter()
                .map(|p| {
                    OptionValueEffect::DenyWrite(PathDescription::Base {
                        base: PathBuf::from("/proc/").join(p),
                        exceptions: vec![],
                    })
                })
                .chain(["kallsyms", "kcore"].iter().map(|p| {
                    OptionValueEffect::RemovePath(PathDescription::Base {
                        base: PathBuf::from("/proc/").join(p),
                        exceptions: vec![],
                    })
                }))
                .chain(iter::once(OptionValueEffect::DenyWrite(
                    PathDescription::base("/sys"),
                )))
                .chain(iter::once(OptionValueEffect::DenyAction(
                    ProgramAction::MountToHost,
                )))
                .collect(),
            )),
        }],
        updater: None,
    }
}

fn build_protect_kernel_modules(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelModules",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::base("/lib/modules/")),
                OptionValueEffect::RemovePath(PathDescription::base("/usr/lib/modules/")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("module")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_protect_kernel_logs(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectKernelLogs",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::base("/proc/kmsg")),
                OptionValueEffect::RemovePath(PathDescription::base("/dev/kmsg")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("syslog")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_protect_control_groups(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectControlGroups",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::base("/sys/fs/cgroup/")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_protect_proc(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectProc",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("ptraceable".to_owned()),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::pattern("^/proc/[0-9]+(/|$)")),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_proc_subset(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProcSubset",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("pid".to_owned()),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::RemovePath(PathDescription::pattern(
                    "^/proc/[^/]*[^0-9/]+[^/]*",
                )),
                OptionValueEffect::DenyAction(ProgramAction::MountToHost),
            ])),
        }],
        updater: None,
    }
}

fn build_lock_personality(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "LockPersonality",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenySyscalls(DenySyscalls::Single(
                "personality",
            ))),
        }],
        updater: None,
    }
}

fn build_restrict_realtime(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "RestrictRealtime",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::SetRealtimeScheduler,
            )),
        }],
        updater: None,
    }
}

fn build_protect_clock(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "ProtectClock",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                OptionValueEffect::DenyWrite(PathDescription::pattern("/dev/rtc.*")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("stime")),
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("clock")),
                OptionValueEffect::DenyAction(ProgramAction::SetAlarm),
            ])),
        }],
        updater: None,
    }
}

fn build_memory_deny_write_execute(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "MemoryDenyWriteExecute",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::WriteExecuteMemoryMapping,
            )),
        }],
        updater: None,
    }
}

fn build_system_call_architectures(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "SystemCallArchitectures",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::String("native".to_owned()),
            desc: OptionEffect::None,
        }],
        updater: None,
    }
}

fn build_private_network(_ctx: &OptionsContext<'_>) -> OptionDescription {
    OptionDescription {
        name: "PrivateNetwork",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::Boolean(true),
            desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                ProgramAction::NetworkActivity(
                    NetworkActivity {
                        af: SetSpecifier::All,
                        proto: SetSpecifier::All,
                        kind: SetSpecifier::All,
                        local_port: SetSpecifier::All,
                        address: SetSpecifier::All,
                    }
                    .into(),
                ),
            )),
        }],
        updater: None,
    }
}

/// Static registry of option specifications with their enable conditions
static OPTION_SPECS: &[OptionSpec] = &[
    // ProtectSystem - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_protect_system,
    },
    // ProtectHome - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_home,
    },
    // PrivateTmp - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_tmp,
    },
    // PrivateDevices - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_devices,
    },
    // PrivateMounts - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_private_mounts,
    },
    // ProtectKernelTunables - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_tunables,
    },
    // ProtectKernelModules - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_modules,
    },
    // ProtectKernelLogs - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_kernel_logs,
    },
    // ProtectControlGroups - system instance only
    OptionSpec {
        enabled_if: |ctx| ctx.is_system_instance(),
        build: build_protect_control_groups,
    },
    // ProtectProc - system instance, systemd >= 247, kernel >= 5.8
    OptionSpec {
        enabled_if: |ctx| {
            ctx.is_system_instance()
                && ctx.systemd_at_least(247, 0)
                && ctx.kernel_at_least(5, 8, 0)
        },
        build: build_protect_proc,
    },
    // ProcSubset - system instance, systemd >= 247, kernel >= 5.8
    OptionSpec {
        enabled_if: |ctx| {
            ctx.is_system_instance()
                && ctx.systemd_at_least(247, 0)
                && ctx.kernel_at_least(5, 8, 0)
        },
        build: build_proc_subset,
    },
    // LockPersonality - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_lock_personality,
    },
    // RestrictRealtime - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_restrict_realtime,
    },
    // ProtectClock - requires namespaces
    OptionSpec {
        enabled_if: |ctx| ctx.can_use_namespaces(),
        build: build_protect_clock,
    },
    // MemoryDenyWriteExecute - always enabled
    OptionSpec {
        enabled_if: always_enabled,
        build: build_memory_deny_write_execute,
    },
    // SystemCallArchitectures - aggressive mode only
    OptionSpec {
        enabled_if: |ctx| matches!(ctx.hardening_opts.mode, HardeningMode::Aggressive),
        build: build_system_call_architectures,
    },
    // PrivateNetwork - namespaces + aggressive mode
    OptionSpec {
        enabled_if: |ctx| {
            ctx.can_use_namespaces() && matches!(ctx.hardening_opts.mode, HardeningMode::Aggressive)
        },
        build: build_private_network,
    },
];

#[expect(clippy::too_many_lines, clippy::similar_names)]
pub(crate) fn build_options(
    systemd_version: &SystemdVersion,
    kernel_version: &KernelVersion,
    sysctl_state: &sysctl::State,
    instance_kind: &systemd::InstanceKind,
    hardening_opts: &HardeningOptions,
) -> Vec<OptionDescription> {
    let ctx = OptionsContext {
        systemd_version,
        kernel_version,
        sysctl_state,
        instance_kind,
        hardening_opts,
    };

    //
    // Warning: options values must be ordered from less to most restrictive
    //

    // Options model does not aim to accurately define the option's effects, it is often an oversimplification.
    // However the model should always tend to make options *more* (or equally as) restrictive than what they really are,
    // as to avoid suggesting options that might break execution.

    // TODO APPROXIMATION
    // Some options implicitly force NoNewPrivileges=true which has some effects in itself,
    // which we need to model

    // Build options from the static registry
    let mut options: Vec<OptionDescription> = OPTION_SPECS
        .iter()
        .filter(|spec| (spec.enabled_if)(&ctx))
        .map(|spec| (spec.build)(&ctx))
        .collect();

    // Additional options with complex updaters that aren't easily expressed in the registry
    if ctx.can_use_namespaces() {
        // https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#ReadWritePaths=
        if ctx.hardening_opts.filesystem_whitelisting {
            options.push(OptionDescription {
                name: "ReadOnlyPaths",
                possible_values: vec![OptionValueDescription {
                    value: OptionValue::List(ListOptionValue {
                        values: vec!["/".to_owned()],
                        value_if_empty: None,
                        option_prefix: "",
                        elem_prefix: "-",
                        repeat_option: false,
                        mode: ListMode::BlackList,
                        mergeable_paths: true,
                    }),
                    desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                        OptionValueEffect::DenyWrite(PathDescription::base("/")),
                        OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                    ])),
                }],
                updater: Some(OptionUpdater {
                    effect: |effect, action, _| {
                        let action_path = match action {
                            ProgramAction::Write(action_path) => action_path.to_owned(),
                            ProgramAction::Create(action_path) => {
                                if let Some(parent) = action_path.parent() {
                                    parent.to_owned()
                                } else {
                                    return None;
                                }
                            }
                            _ => return None,
                        };
                        match effect {
                            OptionValueEffect::DenyWrite(PathDescription::Base {
                                base,
                                exceptions,
                            }) if action_path != Path::new("/") => {
                                let mut new_exceptions = Vec::with_capacity(exceptions.len() + 1);
                                new_exceptions.extend(exceptions.iter().cloned());
                                new_exceptions.push(action_path);
                                Some(OptionValueEffect::DenyWrite(PathDescription::Base {
                                    base: base.to_owned(),
                                    exceptions: new_exceptions,
                                }))
                            }
                            _ => None,
                        }
                    },
                    options: |effect| match effect {
                        OptionValueEffect::DenyWrite(PathDescription::Base {
                            base,
                            exceptions,
                        }) => {
                            vec![
                                OptionWithValue {
                                    name: "ReadOnlyPaths",
                                    value: OptionValue::List(ListOptionValue {
                                    #[expect(clippy::unwrap_used)] // path is from our option, so unicode safe
                                    values: vec![base.to_str().unwrap().to_owned()],
                                    value_if_empty: None,
                                    option_prefix: "",
                                    elem_prefix: "-",
                                    repeat_option: false,
                                    mode: ListMode::BlackList,
                                    mergeable_paths: true,
                                }),
                                },
                                OptionWithValue {
                                    name: "ReadWritePaths",
                                    value: OptionValue::List(ListOptionValue {
                                        values: merge_similar_paths(exceptions, None)
                                            .iter()
                                            .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                            .collect(),
                                        value_if_empty: None,
                                        option_prefix: "",
                                        elem_prefix: "-",
                                        repeat_option: false,
                                        mode: ListMode::WhiteList,
                                        mergeable_paths: true,
                                    }),
                                },
                            ]
                        }
                        OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                            vec![OptionWithValue {
                                name: "PrivateMounts",
                                value: OptionValue::Boolean(true),
                            }]
                        }
                        _ => unreachable!(),
                    },
                    dynamic_option_names: Vec::from([
                        "PrivateMounts",
                        "ReadOnlyPaths",
                        "ReadWritePaths",
                    ]),
                }),
            });

            let mut possible_values = vec![OptionValueDescription {
                value: OptionValue::List(ListOptionValue {
                    values: vec!["/".to_owned()],
                    value_if_empty: None,
                    option_prefix: "",
                    elem_prefix: "-",
                    repeat_option: false,
                    mode: ListMode::BlackList,
                    mergeable_paths: true,
                }),
                desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                    OptionValueEffect::RemovePath(PathDescription::base("/")),
                    OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                ])),
            }];
            // To avoid InaccessiblePaths being completely disabled simply because of the equivalent of 'ls /',
            // we set another option value for each dir directly under /
            let base_paths: Option<Vec<String>> = fs::read_dir("/")
                .ok()
                .and_then(|i| i.collect::<Result<Vec<_>, _>>().ok())
                .and_then(|v| {
                    // Don't make those inaccessible, systemd won't be able to start anything
                    let excluded_run_dirs = [Path::new("/run"), Path::new("/proc")];
                    v.into_iter()
                        .filter(|e| !excluded_run_dirs.contains(&e.path().as_ref()))
                        // systemd follows symlinks when applying option, so exclude them
                        .filter(|e| e.file_type().is_ok_and(|t| !t.is_symlink()))
                        .map(|e| e.path().to_str().map(ToOwned::to_owned))
                        .collect()
                })
                .map(|mut v: Vec<_>| {
                    v.sort_unstable();
                    v
                });
            if let Some(base_paths) = base_paths {
                possible_values.insert(
                    0,
                    OptionValueDescription {
                        value: OptionValue::List(ListOptionValue {
                            values: base_paths.clone(),
                            value_if_empty: None,
                            option_prefix: "",
                            elem_prefix: "-",
                            repeat_option: false,
                            mode: ListMode::BlackList,
                            mergeable_paths: true,
                        }),
                        desc: OptionEffect::Cumulative(
                            base_paths
                                .iter()
                                .map(|p| {
                                    OptionValueEffect::Multiple(vec![
                                        OptionValueEffect::RemovePath(PathDescription::base(p)),
                                        OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                                    ])
                                })
                                .collect(),
                        ),
                    },
                );
            }
            options.push(OptionDescription {
                name: "InaccessiblePaths",
                possible_values,
                updater: Some(OptionUpdater {
                    effect: |effect, action, _| {
                        let (action_path, action_ro) = match action {
                            ProgramAction::Read(action_path) | ProgramAction::Exec(action_path) => {
                                (action_path.to_owned(), true)
                            }
                            ProgramAction::Write(action_path) => (action_path.to_owned(), false),
                            ProgramAction::Create(action_path) => {
                                (action_path.parent().map(Path::to_path_buf)?, false)
                            }
                            _ => return None,
                        };
                        match effect {
                            OptionValueEffect::RemovePath(PathDescription::Base {
                                base,
                                exceptions,
                            }) => {
                                // This will be reached only when first transforming an initial InaccessiblePaths option (RemovePath) into
                                // less restrictive EmptyPaths + exceptions
                                assert!(exceptions.is_empty());
                                let new_exception_path = action_path_exception(action_path);
                                if base.starts_with(&new_exception_path) {
                                    return None;
                                }
                                let (exceptions_ro, exceptions_rw) = if action_ro {
                                    (vec![new_exception_path], vec![])
                                } else {
                                    (vec![], vec![new_exception_path])
                                };
                                Some(OptionValueEffect::EmptyPath(EmptyPathDescription {
                                    base: base.to_owned(),
                                    base_ro: true,
                                    exceptions_ro,
                                    exceptions_rw,
                                }))
                            }
                            OptionValueEffect::EmptyPath(EmptyPathDescription {
                                base,
                                base_ro,
                                exceptions_ro,
                                exceptions_rw,
                            }) => {
                                let mut new_exceptions_ro = Vec::with_capacity(
                                    exceptions_ro.len() + usize::from(action_ro),
                                );
                                new_exceptions_ro.extend(exceptions_ro.iter().cloned());
                                let mut new_exceptions_rw = Vec::with_capacity(
                                    exceptions_rw.len() + usize::from(!action_ro),
                                );
                                new_exceptions_rw.extend(exceptions_rw.iter().cloned());
                                let mut base_ro = *base_ro;
                                let new_exception_path = action_path_exception(action_path);
                                if matches!(action, ProgramAction::Create(_))
                                    && new_exception_path == *base
                                {
                                    base_ro = false;
                                } else {
                                    if base.starts_with(&new_exception_path) {
                                        return None;
                                    }
                                    if action_ro {
                                        new_exceptions_ro.push(new_exception_path);
                                    } else {
                                        new_exceptions_rw.push(new_exception_path);
                                    }
                                }
                                // Remove exceptions in ro list if in rw
                                new_exceptions_ro.retain(|ero| {
                                    !new_exceptions_rw.iter().any(|erw| ero.starts_with(erw))
                                });
                                Some(OptionValueEffect::EmptyPath(EmptyPathDescription {
                                    base: base.to_owned(),
                                    base_ro,
                                    exceptions_ro: new_exceptions_ro,
                                    exceptions_rw: new_exceptions_rw,
                                }))
                            }
                            _ => None,
                        }
                    },
                    options: |effect| match effect {
                        OptionValueEffect::EmptyPath(EmptyPathDescription {
                            base,
                            base_ro,
                            exceptions_ro,
                            exceptions_rw,
                        }) => {
                            // TemporayFileSystem nullifies ReadOnlyPaths, so we must apply read only restrictions here too
                            let mut new_opts = Vec::with_capacity(
                                1 + usize::from(!exceptions_ro.is_empty())
                                    + usize::from(!exceptions_rw.is_empty()),
                            );
                            new_opts.push(OptionWithValue {
                                name: "TemporaryFileSystem",
                                value: OptionValue::List(ListOptionValue {
                                #[expect(clippy::unwrap_used)] // path is from our option, so unicode safe
                                values: vec![if *base_ro {
                                    format!("{}:ro", base.to_str().unwrap())
                                } else {
                                    base.to_str().unwrap().to_owned()
                                }],
                                value_if_empty: None,
                                option_prefix: "",
                                elem_prefix: "",
                                repeat_option: false,
                                mode: ListMode::BlackList,
                                mergeable_paths: true,
                            }),
                            });
                            let merged_exceptions_ro: Vec<_> = {
                                let merged_paths = merge_similar_paths(exceptions_ro, None);
                                if merged_paths.iter().any(|p| *base_ro && (p == base)) {
                                    // The exception nullifies the option, bail out
                                    return vec![];
                                }
                                merged_paths
                                    .into_iter()
                                    .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                    .collect()
                            };
                            if !merged_exceptions_ro.is_empty() {
                                new_opts.push(OptionWithValue {
                                    name: "BindReadOnlyPaths",
                                    value: OptionValue::List(ListOptionValue {
                                        values: merged_exceptions_ro,
                                        value_if_empty: None,
                                        option_prefix: "",
                                        elem_prefix: "-",
                                        repeat_option: false,
                                        mode: ListMode::WhiteList,
                                        mergeable_paths: true,
                                    }),
                                });
                            }
                            let merged_exceptions_rw: Vec<_> = {
                                let merged_paths = merge_similar_paths(exceptions_rw, None);
                                if merged_paths.iter().any(|p| p == base) {
                                    // The exception nullifies the option, bail out
                                    return vec![];
                                }
                                merged_paths
                                    .into_iter()
                                    .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                    .collect()
                            };
                            if !merged_exceptions_rw.is_empty() {
                                new_opts.push(OptionWithValue {
                                    name: "BindPaths",
                                    value: OptionValue::List(ListOptionValue {
                                        values: merged_exceptions_rw,
                                        value_if_empty: None,
                                        option_prefix: "",
                                        elem_prefix: "-",
                                        repeat_option: false,
                                        mode: ListMode::WhiteList,
                                        mergeable_paths: true,
                                    }),
                                });
                            }
                            new_opts
                        }
                        OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                            vec![OptionWithValue {
                                name: "PrivateMounts",
                                value: OptionValue::Boolean(true),
                            }]
                        }
                        #[expect(clippy::unwrap_used)]
                        OptionValueEffect::RemovePath(PathDescription::Base {
                            base,
                            exceptions,
                        }) => {
                            assert!(exceptions.is_empty());
                            vec![OptionWithValue {
                                name: "InaccessiblePaths",
                                value: OptionValue::List(ListOptionValue {
                                    values: vec![base.to_str().unwrap().to_owned()],
                                    value_if_empty: None,
                                    option_prefix: "",
                                    elem_prefix: "-",
                                    repeat_option: false,
                                    mode: ListMode::BlackList,
                                    mergeable_paths: true,
                                }),
                            }]
                        }
                        _ => unreachable!(),
                    },
                    dynamic_option_names: Vec::from([
                        "PrivateMounts",
                        "TemporaryFileSystem",
                        "BindReadOnlyPaths",
                        "BindPaths",
                    ]),
                }),
            });

            options.push(OptionDescription {
                name: "NoExecPaths",
                possible_values: vec![OptionValueDescription {
                    value: OptionValue::List(ListOptionValue {
                        values: vec!["/".to_owned()],
                        value_if_empty: None,
                        option_prefix: "",
                        elem_prefix: "-",
                        repeat_option: false,
                        mode: ListMode::BlackList,
                        mergeable_paths: true,
                    }),
                    desc: OptionEffect::Simple(OptionValueEffect::Multiple(vec![
                        OptionValueEffect::DenyExec(PathDescription::base("/")),
                        OptionValueEffect::DenyAction(ProgramAction::MountToHost),
                    ])),
                }],
                updater: Some(OptionUpdater {
                    effect: |effect, action, _| {
                        let ProgramAction::Exec(action_path) = action else {
                            return None;
                        };
                        match effect {
                            OptionValueEffect::DenyExec(PathDescription::Base {
                                base,
                                exceptions,
                            }) if action_path != Path::new("/") => {
                                let mut new_exceptions = Vec::with_capacity(exceptions.len() + 1);
                                new_exceptions.extend(exceptions.iter().cloned());
                                new_exceptions.push(action_path.to_owned());
                                Some(OptionValueEffect::DenyExec(PathDescription::Base {
                                    base: base.to_owned(),
                                    exceptions: new_exceptions,
                                }))
                            }
                            _ => None,
                        }
                    },
                    options: |effect| match effect {
                        OptionValueEffect::DenyExec(PathDescription::Base { base, exceptions }) => {
                            vec![
                                OptionWithValue {
                                    name: "NoExecPaths",
                                    value: OptionValue::List(ListOptionValue {
                                    #[expect(clippy::unwrap_used)] // path is from our option, so unicode safe
                                    values: vec![base.to_str().unwrap().to_owned()],
                                    value_if_empty: None,
                                    option_prefix: "",
                                    elem_prefix: "-",
                                    repeat_option: false,
                                    mode: ListMode::BlackList,
                                    mergeable_paths: true,
                                }),
                                },
                                OptionWithValue {
                                    name: "ExecPaths",
                                    value: OptionValue::List(ListOptionValue {
                                        values: merge_similar_paths(exceptions, None)
                                            .iter()
                                            .filter_map(|p| p.to_str().map(ToOwned::to_owned))
                                            .collect(),
                                        value_if_empty: None,
                                        option_prefix: "",
                                        elem_prefix: "-",
                                        repeat_option: false,
                                        mode: ListMode::WhiteList,
                                        mergeable_paths: true,
                                    }),
                                },
                            ]
                        }
                        OptionValueEffect::DenyAction(ProgramAction::MountToHost) => {
                            vec![OptionWithValue {
                                name: "PrivateMounts",
                                value: OptionValue::Boolean(true),
                            }]
                        }
                        _ => unreachable!(),
                    },
                    dynamic_option_names: Vec::from(["NoExecPaths", "PrivateMounts", "ExecPaths"]),
                }),
            });
        }
    }

    // https://www.freedesktop.org/software/systemd/man/systemd.exec.html#RestrictAddressFamilies=
    // https://man7.org/linux/man-pages/man7/address_families.7.html
    // curl https://man7.org/linux/man-pages/man7/address_families.7.html | grep -o 'AF_[A-Za-z0-9]*' | sort -u | xargs -I'{}' echo \"'{}'\",
    let afs = [
        "AF_ALG",
        "AF_APPLETALK",
        "AF_ATMPVC",
        "AF_ATMSVC",
        "AF_AX25",
        "AF_BLUETOOTH",
        "AF_BRIDGE",
        "AF_CAIF",
        "AF_CAN",
        "AF_DECnet",
        "AF_ECONET",
        "AF_IB",
        "AF_IEEE802154",
        "AF_INET",
        "AF_INET6",
        "AF_IPX",
        "AF_IRDA",
        "AF_ISDN",
        "AF_IUCV",
        "AF_KCM",
        "AF_KEY",
        "AF_LLC",
        "AF_LOCAL",
        "AF_MPLS",
        "AF_NETBEUI",
        "AF_NETLINK",
        "AF_NETROM",
        "AF_PACKET",
        "AF_PHONET",
        "AF_PPPOX",
        "AF_QIPCRTR",
        "AF_RDS",
        "AF_ROSE",
        "AF_RXRPC",
        "AF_SECURITY",
        "AF_SMC",
        "AF_TIPC",
        "AF_UNIX",
        "AF_VSOCK",
        "AF_WANPIPE",
        "AF_X25",
        "AF_XDP",
    ];
    options.push(OptionDescription {
        name: "RestrictAddressFamilies",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: afs.iter().map(|s| (*s).to_owned()).collect(),
                value_if_empty: Some("none"),
                option_prefix: "",
                elem_prefix: "",
                repeat_option: false,
                mode: ListMode::WhiteList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(
                afs.into_iter()
                    .map(|af| {
                        OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                            NetworkActivity {
                                #[expect(clippy::unwrap_used)]
                                af: SetSpecifier::One(af.parse().unwrap()),
                                proto: SetSpecifier::All,
                                kind: SetSpecifier::All,
                                local_port: SetSpecifier::All,
                                address: SetSpecifier::All,
                            }
                            .into(),
                        ))
                    })
                    .collect(),
            ),
        }],
        updater: None,
    });

    // https://www.freedesktop.org/software/systemd/man/systemd.resource-control.html#SocketBindAllow=bind-rule
    let deny_binds: Vec<_> = SocketFamily::iter()
        .take(2)
        .cartesian_product(SocketProtocol::iter().take(2))
        .collect();
    options.push(OptionDescription {
        name: "SocketBindDeny",
        possible_values: vec![OptionValueDescription {
            value: OptionValue::List(ListOptionValue {
                values: deny_binds
                    .iter()
                    .map(|(af, proto)| format!("{af}:{proto}"))
                    .collect(),
                value_if_empty: None,
                option_prefix: "",
                elem_prefix: "",
                repeat_option: true,
                mode: ListMode::BlackList,
                mergeable_paths: false,
            }),
            desc: OptionEffect::Cumulative(
                deny_binds
                    .into_iter()
                    .map(|(af, proto)| {
                        OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                            NetworkActivity {
                                af: SetSpecifier::One(af),
                                proto: SetSpecifier::One(proto),
                                kind: SetSpecifier::One(NetworkActivityKind::Bind),
                                local_port: SetSpecifier::All,
                                address: SetSpecifier::All,
                            }
                            .into(),
                        ))
                    })
                    .collect(),
            ),
        }],
        updater: ctx.hardening_opts.network_firewalling.then_some(OptionUpdater {
            effect: |e, a, _| {
                let OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(effect_na)) = e
                else {
                    return None;
                };
                let local_port = if let ProgramAction::NetworkActivity(na) = a {
                    if let SetSpecifier::One(local_port) = &na.as_ref().local_port {
                        local_port
                    } else {
                        return None;
                    }
                } else {
                    return None;
                };
                let mut new_eff_local_port = effect_na.local_port.clone();
                new_eff_local_port.remove(local_port);
                Some(OptionValueEffect::DenyAction(
                    ProgramAction::NetworkActivity(
                        NetworkActivity {
                            af: effect_na.af.clone(),
                            proto: effect_na.proto.clone(),
                            kind: effect_na.kind.clone(),
                            local_port: new_eff_local_port,
                            address: effect_na.address.clone(),
                        }
                        .into(),
                    ),
                ))
            },
            options: |e| {
                let (af, proto, local_port) =
                    if let OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(na)) = e {
                        if let NetworkActivity {
                            af: SetSpecifier::One(af),
                            proto: SetSpecifier::One(proto),
                            local_port,
                            ..
                        } = na.as_ref()
                        {
                            (af, proto, local_port)
                        } else {
                            unreachable!()
                        }
                    } else {
                        unreachable!();
                    };
                let port_exceptions = local_port.excluded_elements();
                let mut opts = Vec::with_capacity(1 + port_exceptions.len());
                opts.push(OptionWithValue {
                    name: "SocketBindDeny",
                    value: OptionValue::String(format!("{af}:{proto}")),
                });
                opts.extend(
                    port_exceptions
                        .iter()
                        .map(|port_exception| OptionWithValue {
                            name: "SocketBindAllow",
                            value: OptionValue::String(format!("{af}:{proto}:{port_exception}")),
                        }),
                );
                opts
            },
            dynamic_option_names: Vec::from(["SocketBindDeny"]),
        }),
    });

    // https://www.freedesktop.org/software/systemd/man/latest/systemd.resource-control.html#IPAddressAllow=ADDRESS%5B/PREFIXLENGTH%5D%E2%80%A6
    if ctx.hardening_opts.network_firewalling {
        options.push(OptionDescription {
            name: "IPAddressDeny",
            possible_values: vec![OptionValueDescription {
                value: OptionValue::String("any".into()),
                desc: OptionEffect::Simple(OptionValueEffect::DenyAction(
                    ProgramAction::NetworkActivity(
                        NetworkActivity {
                            af: SetSpecifier::Some(vec![SocketFamily::Ipv4, SocketFamily::Ipv6]),
                            proto: SetSpecifier::All,
                            kind: SetSpecifier::Some(NetworkActivityKind::ADDRESSED.to_vec()),
                            local_port: SetSpecifier::All,
                            address: SetSpecifier::All,
                        }
                        .into(),
                    ),
                )),
            }],
            updater: Some(OptionUpdater {
                effect: |effect, action, _| {
                    let OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(effect_na)) =
                        effect
                    else {
                        return None;
                    };
                    let action_addr = if let ProgramAction::NetworkActivity(na) = action {
                        if let NetworkActivity {
                            address: SetSpecifier::One(action_addr),
                            ..
                        } = na.as_ref()
                        {
                            action_addr
                        } else {
                            return None;
                        }
                    } else {
                        return None;
                    };
                    let mut new_effect_address = effect_na.address.clone();
                    new_effect_address.remove(action_addr);
                    Some(OptionValueEffect::DenyAction(
                        ProgramAction::NetworkActivity(
                            NetworkActivity {
                                address: new_effect_address,
                                ..*effect_na.to_owned()
                            }
                            .into(),
                        ),
                    ))
                },
                options: |effect| match effect {
                    OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(na)) => {
                        let NetworkActivity { address, .. } = na.as_ref();
                        vec![
                            OptionWithValue {
                                name: "IPAddressDeny",
                                value: OptionValue::String("any".into()),
                            },
                            OptionWithValue {
                                name: "IPAddressAllow",
                                value: OptionValue::List(ListOptionValue {
                                    values: address
                                        .excluded_elements()
                                        .into_iter()
                                        .map(|e| e.to_string())
                                        .collect(),
                                    value_if_empty: None,
                                    option_prefix: "",
                                    elem_prefix: "",
                                    repeat_option: false,
                                    mode: ListMode::WhiteList,
                                    mergeable_paths: false,
                                }),
                            },
                        ]
                    }
                    _ => unreachable!(),
                },
                dynamic_option_names: vec!["IPAddressDeny", "IPAddressAllow"],
            }),
        });
    }

    if ctx.can_use_namespaces() {
        // https://www.freedesktop.org/software/systemd/man/latest/systemd.exec.html#CapabilityBoundingSet=
        // Note: we don't want to duplicate the kernel permission checking logic here, which would be
        // a maintenance nightmare, so in most case we over (never under!) simplify the capability's effect
        // or we don't implement it at all if too complex because the risk of breakage is too high
        let cap_effects = [
            // CAP_AUDIT_CONTROL, CAP_AUDIT_READ, CAP_AUDIT_WRITE: requires netlink socket message handling
            (
                "CAP_BLOCK_SUSPEND",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenyWrite(PathDescription::base("/proc/sys/wake_lock")),
                    OptionValueEffect::DenyAction(ProgramAction::Wakeup),
                ]),
            ),
            (
                "CAP_BPF",
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("bpf")),
            ),
            // CAP_CHECKPOINT_RESTORE: too complex?
            (
                "CAP_CHOWN",
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("chown")),
            ),
            // CAP_DAC_OVERRIDE: too complex?
            // CAP_DAC_READ_SEARCH: too complex?
            // CAP_FOWNER: too complex?
            // CAP_FSETID: too complex?
            (
                "CAP_IPC_LOCK",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Class("memlock")),
                    OptionValueEffect::DenyAction(ProgramAction::LockMemoryMapping),
                    OptionValueEffect::DenyAction(ProgramAction::HugePageMemoryMapping),
                ]),
            ),
            // CAP_IPC_OWNER: too complex?
            (
                "CAP_KILL",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenyAction(ProgramAction::KillOther),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("ioctl")), // TODO KDSIGACCEPT only
                ]),
            ),
            // TODO CAP_LEASE
            // TODO CAP_LINUX_IMMUTABLE
            // CAP_MAC_ADMIN: too complex?
            // CAP_MAC_OVERRIDE: too complex?
            (
                "CAP_MKNOD",
                OptionValueEffect::DenyAction(ProgramAction::MknodSpecial),
            ),
            // CAP_NET_ADMIN: too complex?
            // CAP_NET_BIND_SERVICE would be too complex/unreliable to handle:
            // - for IPv4 sockets, either PROT_SOCK or net.ipv4.ip_unprivileged_port_start sysctl control the provileged port threshold
            // - for other socket families, rules are different
            // CAP_NET_BROADCAST: unused
            (
                "CAP_NET_RAW",
                OptionValueEffect::Multiple(
                    iter::once(OptionValueEffect::DenyAction(
                        ProgramAction::NetworkActivity(
                            NetworkActivity {
                                af: SetSpecifier::One(SocketFamily::Other("AF_PACKET".into())),
                                proto: SetSpecifier::All,
                                kind: SetSpecifier::All,
                                local_port: SetSpecifier::All,
                                address: SetSpecifier::All,
                            }
                            .into(),
                        ),
                    ))
                    .chain(
                        // AF_NETLINK sockets use SOCK_RAW, but does not require CAP_NET_RAW
                        afs.iter().filter(|af| **af != "AF_NETLINK").map(|af| {
                            OptionValueEffect::DenyAction(ProgramAction::NetworkActivity(
                                NetworkActivity {
                                    #[expect(clippy::unwrap_used)]
                                    af: SetSpecifier::One(af.parse().unwrap()),
                                    proto: SetSpecifier::One(SocketProtocol::Other(
                                        "SOCK_RAW".into(),
                                    )),
                                    kind: SetSpecifier::All,
                                    local_port: SetSpecifier::All,
                                    address: SetSpecifier::All,
                                }
                                .into(),
                            ))
                        }),
                    )
                    .collect(),
                    // TODO non local bind
                ),
            ),
            (
                "CAP_PERFMON",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("perf_event_open")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("bpf")),
                ]),
            ),
            // CAP_SETFCAP: too complex?
            // TODO CAP_SETGID
            // TODO CAP_SETPCAP
            // TODO CAP_SETUID
            // CAP_SYS_ADMIN: definitely too complex
            (
                "CAP_SYS_BOOT",
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("reboot")),
            ),
            (
                "CAP_SYS_CHROOT",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("chroot")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("setns")),
                ]),
            ),
            (
                "CAP_SYS_MODULE",
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("module")),
            ),
            (
                "CAP_SYS_NICE",
                OptionValueEffect::DenySyscalls(DenySyscalls::Class("resources")),
            ),
            (
                "CAP_SYS_PACCT",
                OptionValueEffect::DenySyscalls(DenySyscalls::Single("acct")),
            ),
            (
                "CAP_SYS_PTRACE",
                OptionValueEffect::Multiple(vec![
                    // TODO distinguish other processes
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("ptrace)")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("get_robust_list")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("process_vm_readv")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("process_vm_writev")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("kcmp")),
                ]),
            ),
            // CAP_SYS_RAWIO: too complex?
            // CAP_SYS_RESOURCE: too complex?
            (
                "CAP_SYS_TIME",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Class("clock")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("stime")),
                ]),
            ),
            (
                "CAP_SYS_TTY_CONFIG",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("vhangup")),
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("ioctl")), // TODO only consider tty related ioctl?
                ]),
            ),
            (
                "CAP_SYSLOG",
                OptionValueEffect::Multiple(vec![
                    OptionValueEffect::DenySyscalls(DenySyscalls::Single("syslog")),
                    OptionValueEffect::DenyAction(ProgramAction::Read("/dev/kmsg".into())),
                ]),
            ),
            (
                "CAP_WAKE_ALARM",
                OptionValueEffect::DenyAction(ProgramAction::SetAlarm),
            ),
        ];
        options.push(OptionDescription {
            name: "CapabilityBoundingSet",
            possible_values: vec![OptionValueDescription {
                value: OptionValue::List(ListOptionValue {
                    values: cap_effects.iter().map(|(c, _e)| (*c).to_owned()).collect(),
                    value_if_empty: None,
                    option_prefix: "~",
                    elem_prefix: "",
                    repeat_option: false,
                    mode: ListMode::BlackList,
                    mergeable_paths: false,
                }),
                desc: OptionEffect::Cumulative(cap_effects.into_iter().map(|(_c, e)| e).collect()),
            }],
            updater: None,
        });
    }

    // https://www.freedesktop.org/software/systemd/man/systemd.exec.html#SystemCallFilter=
    //
    // Also change the default behavior when calling a denied syscall to return EPERM instead of killing
    // the program.
    // Rationale:
    // Some programs call chown as non root even though it always fails, and ignore the error. Since the call
    // fails, we don't monitor it, but if we deny the chown syscall, the program gets killed with SIGSYS
    // signal when it makes the call, so change the default to just return EPERM.
    // Real world example: https://github.com/tjko/jpegoptim/blob/v1.5.5/jpegoptim.c#L1097-L1099
    //
    if !matches!(ctx.hardening_opts.mode, HardeningMode::Generic) {
        let mut syscall_classes: Vec<_> = SYSCALL_CLASSES.keys().copied().collect();
        syscall_classes.sort_unstable();
        options.push(OptionDescription {
            name: "SystemCallFilter",
            possible_values: vec![OptionValueDescription {
                value: OptionValue::List(ListOptionValue {
                    values: syscall_classes
                        .iter()
                        .map(|c| format!("@{c}:EPERM"))
                        .collect(),
                    value_if_empty: None,
                    option_prefix: "~",
                    elem_prefix: "",
                    repeat_option: false,
                    mode: ListMode::BlackList,
                    mergeable_paths: false,
                }),
                desc: OptionEffect::Cumulative(
                    syscall_classes
                        .into_iter()
                        .map(|class| OptionValueEffect::DenySyscalls(DenySyscalls::Class(class)))
                        .collect(),
                ),
            }],
            updater: None,
        });
    }

    if let Some(options_to_keep) = &ctx.hardening_opts.systemd_options {
        options.retain(|o| options_to_keep.iter().any(|k| o.name == k));
    }

    log::debug!("{options:#?}");
    options
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn merge_similar_paths_works() {
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/ab/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ab/ab3"),
                    PathBuf::from("/a/ab/ab4/abc")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/ab")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a1/ab/ab1"),
                    PathBuf::from("/a2/ab/ab2"),
                    PathBuf::from("/a3/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![
                PathBuf::from("/a1/ab/ab1"),
                PathBuf::from("/a2/ab/ab2"),
                PathBuf::from("/a3/ab/ab3")
            ]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/ab/ab2"),
                    PathBuf::from("/a/ac/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a")]
        );
        assert_eq!(
            merge_similar_paths(
                &[
                    PathBuf::from("/a/aa/ab1"),
                    PathBuf::from("/a/aa/ab2"),
                    PathBuf::from("/a/ab/ab3")
                ],
                Some(NonZeroUsize::new(2).unwrap())
            ),
            vec![PathBuf::from("/a/aa"), PathBuf::from("/a/ab")]
        );
        for threshold in [2, 5] {
            assert_eq!(
                merge_similar_paths(
                    &[
                        PathBuf::from("/a"),
                        PathBuf::from("/a/b"),
                        PathBuf::from("/a/b/c"),
                        PathBuf::from("/d/b/c"),
                    ],
                    Some(NonZeroUsize::new(threshold).unwrap())
                ),
                vec![PathBuf::from("/a"), PathBuf::from("/d/b/c")]
            );
        }
    }
}
